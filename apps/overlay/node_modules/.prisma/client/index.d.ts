
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Seller
 */

export type Seller = {
  id: number
  email: string
  name: string | null
  password: string | null
}

/**
 * Model MailVerificationCode
 */

export type MailVerificationCode = {
  id: number
  email: string
  verificationCode: string
  createDate: Date
}

/**
 * Model SellerSocialAccount
 */

export type SellerSocialAccount = {
  serviceId: string
  provider: string
  name: string
  registDate: Date
  profileImage: string | null
  accessToken: string | null
  refreshToken: string | null
  sellerId: number
}

/**
 * Model Goods
 */

export type Goods = {
  id: number
  sellerId: number
  goods_name: string
  summary: string
  goods_status: GoodsStatus
  cancel_type: string
  contents: string | null
  contents_mobile: string | null
  common_contents: string
  shipping_policy: ShopOrGoods
  goods_shipping_policy: LimitOrUnlimit
  unlimit_shipping_price: number | null
  limit_shipping_ea: number | null
  limit_shipping_price: number | null
  limit_shipping_subprice: number | null
  shipping_weight_policy: ShopOrGoods
  min_purchase_limit: LimitOrUnlimit
  min_purchase_ea: number | null
  max_purchase_limit: LimitOrUnlimit
  max_purchase_ea: number | null
  max_urchase_order_limit: number | null
  admin_memo: string | null
  option_use: string
  option_view_type: OptionViewType
  option_suboption_use: string
  member_input_use: string
  image: string
}

/**
 * Model GoodsConfirmation
 */

export type GoodsConfirmation = {
  id: number
  goodsId: number
  status: GoodsConfirmationStatuses
  firstmallGoodsConnectionId: number | null
}

/**
 * Model GoodsOptions
 */

export type GoodsOptions = {
  id: number
  goodsId: number
  default_option: YesOrNo
  option_type: string
  option_title: string | null
  option_code: string | null
  consumer_price: Prisma.Decimal
  price: Prisma.Decimal
  color: string | null
  weight: number | null
  option_view: YesOrNo_UPPERCASE
}

/**
 * Model GoodsOptionsSupplies
 */

export type GoodsOptionsSupplies = {
  id: number
  goodsOptionsId: number
  stock: number
  badstock: number | null
  safe_stock: number | null
}

/**
 * Model LiveCommerceRanking
 */

export type LiveCommerceRanking = {
  id: number
  nickname: string
  text: string
  price: number
  phoneCallEventFlag: string
  loginFlag: string
  createdAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const GoodsStatus: {
  normal: 'normal',
  runout: 'runout',
  purchasing: 'purchasing',
  unsold: 'unsold'
};

export type GoodsStatus = (typeof GoodsStatus)[keyof typeof GoodsStatus]


export const ShopOrGoods: {
  shop: 'shop',
  goods: 'goods'
};

export type ShopOrGoods = (typeof ShopOrGoods)[keyof typeof ShopOrGoods]


export const LimitOrUnlimit: {
  unlimit: 'unlimit',
  limit: 'limit'
};

export type LimitOrUnlimit = (typeof LimitOrUnlimit)[keyof typeof LimitOrUnlimit]


export const OptionViewType: {
  divide: 'divide',
  join: 'join'
};

export type OptionViewType = (typeof OptionViewType)[keyof typeof OptionViewType]


export const GoodsConfirmationStatuses: {
  waiting: 'waiting',
  confirmed: 'confirmed',
  rejected: 'rejected'
};

export type GoodsConfirmationStatuses = (typeof GoodsConfirmationStatuses)[keyof typeof GoodsConfirmationStatuses]


export const YesOrNo: {
  y: 'y',
  n: 'n'
};

export type YesOrNo = (typeof YesOrNo)[keyof typeof YesOrNo]


export const YesOrNo_UPPERCASE: {
  Y: 'Y',
  N: 'N'
};

export type YesOrNo_UPPERCASE = (typeof YesOrNo_UPPERCASE)[keyof typeof YesOrNo_UPPERCASE]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Sellers
 * const sellers = await prisma.seller.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Sellers
   * const sellers = await prisma.seller.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.$executeRaw``, values will be escaped automatically
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.$executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.$queryRaw``, values will be escaped automatically
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.$queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.seller`: Exposes CRUD operations for the **Seller** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sellers
    * const sellers = await prisma.seller.findMany()
    * ```
    */
  get seller(): Prisma.SellerDelegate<GlobalReject>;

  /**
   * `prisma.mailVerificationCode`: Exposes CRUD operations for the **MailVerificationCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MailVerificationCodes
    * const mailVerificationCodes = await prisma.mailVerificationCode.findMany()
    * ```
    */
  get mailVerificationCode(): Prisma.MailVerificationCodeDelegate<GlobalReject>;

  /**
   * `prisma.sellerSocialAccount`: Exposes CRUD operations for the **SellerSocialAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellerSocialAccounts
    * const sellerSocialAccounts = await prisma.sellerSocialAccount.findMany()
    * ```
    */
  get sellerSocialAccount(): Prisma.SellerSocialAccountDelegate<GlobalReject>;

  /**
   * `prisma.goods`: Exposes CRUD operations for the **Goods** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Goods
    * const goods = await prisma.goods.findMany()
    * ```
    */
  get goods(): Prisma.GoodsDelegate<GlobalReject>;

  /**
   * `prisma.goodsConfirmation`: Exposes CRUD operations for the **GoodsConfirmation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoodsConfirmations
    * const goodsConfirmations = await prisma.goodsConfirmation.findMany()
    * ```
    */
  get goodsConfirmation(): Prisma.GoodsConfirmationDelegate<GlobalReject>;

  /**
   * `prisma.goodsOptions`: Exposes CRUD operations for the **GoodsOptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoodsOptions
    * const goodsOptions = await prisma.goodsOptions.findMany()
    * ```
    */
  get goodsOptions(): Prisma.GoodsOptionsDelegate<GlobalReject>;

  /**
   * `prisma.goodsOptionsSupplies`: Exposes CRUD operations for the **GoodsOptionsSupplies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoodsOptionsSupplies
    * const goodsOptionsSupplies = await prisma.goodsOptionsSupplies.findMany()
    * ```
    */
  get goodsOptionsSupplies(): Prisma.GoodsOptionsSuppliesDelegate<GlobalReject>;

  /**
   * `prisma.liveCommerceRanking`: Exposes CRUD operations for the **LiveCommerceRanking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiveCommerceRankings
    * const liveCommerceRankings = await prisma.liveCommerceRanking.findMany()
    * ```
    */
  get liveCommerceRanking(): Prisma.LiveCommerceRankingDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.28.0
   * Query Engine version: 89facabd0366f63911d089156a7a70125bfbcd27
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Seller: 'Seller',
    MailVerificationCode: 'MailVerificationCode',
    SellerSocialAccount: 'SellerSocialAccount',
    Goods: 'Goods',
    GoodsConfirmation: 'GoodsConfirmation',
    GoodsOptions: 'GoodsOptions',
    GoodsOptionsSupplies: 'GoodsOptionsSupplies',
    LiveCommerceRanking: 'LiveCommerceRanking'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model Seller
   */


  export type AggregateSeller = {
    _count: SellerCountAggregateOutputType | null
    count: SellerCountAggregateOutputType | null
    _avg: SellerAvgAggregateOutputType | null
    avg: SellerAvgAggregateOutputType | null
    _sum: SellerSumAggregateOutputType | null
    sum: SellerSumAggregateOutputType | null
    _min: SellerMinAggregateOutputType | null
    min: SellerMinAggregateOutputType | null
    _max: SellerMaxAggregateOutputType | null
    max: SellerMaxAggregateOutputType | null
  }

  export type SellerAvgAggregateOutputType = {
    id: number | null
  }

  export type SellerSumAggregateOutputType = {
    id: number | null
  }

  export type SellerMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
  }

  export type SellerMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
  }

  export type SellerCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    _all: number
  }


  export type SellerAvgAggregateInputType = {
    id?: true
  }

  export type SellerSumAggregateInputType = {
    id?: true
  }

  export type SellerMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
  }

  export type SellerMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
  }

  export type SellerCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    _all?: true
  }

  export type SellerAggregateArgs = {
    /**
     * Filter which Seller to aggregate.
     * 
    **/
    where?: SellerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sellers to fetch.
     * 
    **/
    orderBy?: Enumerable<SellerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SellerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sellers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sellers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sellers
    **/
    _count?: true | SellerCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | SellerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellerAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: SellerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellerSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: SellerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellerMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: SellerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellerMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: SellerMaxAggregateInputType
  }

  export type GetSellerAggregateType<T extends SellerAggregateArgs> = {
        [P in keyof T & keyof AggregateSeller]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeller[P]>
      : GetScalarType<T[P], AggregateSeller[P]>
  }


    
    
  export type SellerGroupByArgs = {
    where?: SellerWhereInput
    orderBy?: Enumerable<SellerOrderByInput>
    by: Array<SellerScalarFieldEnum>
    having?: SellerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellerCountAggregateInputType | true
    _avg?: SellerAvgAggregateInputType
    _sum?: SellerSumAggregateInputType
    _min?: SellerMinAggregateInputType
    _max?: SellerMaxAggregateInputType
  }


  export type SellerGroupByOutputType = {
    id: number
    email: string
    name: string | null
    password: string | null
    _count: SellerCountAggregateOutputType | null
    _avg: SellerAvgAggregateOutputType | null
    _sum: SellerSumAggregateOutputType | null
    _min: SellerMinAggregateOutputType | null
    _max: SellerMaxAggregateOutputType | null
  }

  type GetSellerGroupByPayload<T extends SellerGroupByArgs> = Promise<
    Array<
      PickArray<SellerGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof SellerGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], SellerGroupByOutputType[P]> 
            : GetScalarType<T[P], SellerGroupByOutputType[P]>
        }
      > 
    >


  export type SellerSelect = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    socialAccounts?: boolean | SellerSocialAccountFindManyArgs
    goods?: boolean | GoodsFindManyArgs
  }

  export type SellerInclude = {
    socialAccounts?: boolean | SellerSocialAccountFindManyArgs
    goods?: boolean | GoodsFindManyArgs
  }

  export type SellerGetPayload<
    S extends boolean | null | undefined | SellerArgs,
    U = keyof S
      > = S extends true
        ? Seller
    : S extends undefined
    ? never
    : S extends SellerArgs | SellerFindManyArgs
    ?'include' extends U
    ? Seller  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'socialAccounts'
        ? Array < SellerSocialAccountGetPayload<S['include'][P]>>  :
        P extends 'goods'
        ? Array < GoodsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Seller ?Seller [P]
  : 
          P extends 'socialAccounts'
        ? Array < SellerSocialAccountGetPayload<S['select'][P]>>  :
        P extends 'goods'
        ? Array < GoodsGetPayload<S['select'][P]>>  : never
  } 
    : Seller
  : Seller


  type SellerCountArgs = Merge<
    Omit<SellerFindManyArgs, 'select' | 'include'> & {
      select?: SellerCountAggregateInputType | true
    }
  >

  export interface SellerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Seller that matches the filter.
     * @param {SellerFindUniqueArgs} args - Arguments to find a Seller
     * @example
     * // Get one Seller
     * const seller = await prisma.seller.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SellerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SellerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Seller'> extends True ? CheckSelect<T, Prisma__SellerClient<Seller>, Prisma__SellerClient<SellerGetPayload<T>>> : CheckSelect<T, Prisma__SellerClient<Seller | null >, Prisma__SellerClient<SellerGetPayload<T> | null >>

    /**
     * Find the first Seller that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerFindFirstArgs} args - Arguments to find a Seller
     * @example
     * // Get one Seller
     * const seller = await prisma.seller.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SellerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SellerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Seller'> extends True ? CheckSelect<T, Prisma__SellerClient<Seller>, Prisma__SellerClient<SellerGetPayload<T>>> : CheckSelect<T, Prisma__SellerClient<Seller | null >, Prisma__SellerClient<SellerGetPayload<T> | null >>

    /**
     * Find zero or more Sellers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sellers
     * const sellers = await prisma.seller.findMany()
     * 
     * // Get first 10 Sellers
     * const sellers = await prisma.seller.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellerWithIdOnly = await prisma.seller.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SellerFindManyArgs>(
      args?: SelectSubset<T, SellerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Seller>>, PrismaPromise<Array<SellerGetPayload<T>>>>

    /**
     * Create a Seller.
     * @param {SellerCreateArgs} args - Arguments to create a Seller.
     * @example
     * // Create one Seller
     * const Seller = await prisma.seller.create({
     *   data: {
     *     // ... data to create a Seller
     *   }
     * })
     * 
    **/
    create<T extends SellerCreateArgs>(
      args: SelectSubset<T, SellerCreateArgs>
    ): CheckSelect<T, Prisma__SellerClient<Seller>, Prisma__SellerClient<SellerGetPayload<T>>>

    /**
     * Create many Sellers.
     *     @param {SellerCreateManyArgs} args - Arguments to create many Sellers.
     *     @example
     *     // Create many Sellers
     *     const seller = await prisma.seller.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SellerCreateManyArgs>(
      args?: SelectSubset<T, SellerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Seller.
     * @param {SellerDeleteArgs} args - Arguments to delete one Seller.
     * @example
     * // Delete one Seller
     * const Seller = await prisma.seller.delete({
     *   where: {
     *     // ... filter to delete one Seller
     *   }
     * })
     * 
    **/
    delete<T extends SellerDeleteArgs>(
      args: SelectSubset<T, SellerDeleteArgs>
    ): CheckSelect<T, Prisma__SellerClient<Seller>, Prisma__SellerClient<SellerGetPayload<T>>>

    /**
     * Update one Seller.
     * @param {SellerUpdateArgs} args - Arguments to update one Seller.
     * @example
     * // Update one Seller
     * const seller = await prisma.seller.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SellerUpdateArgs>(
      args: SelectSubset<T, SellerUpdateArgs>
    ): CheckSelect<T, Prisma__SellerClient<Seller>, Prisma__SellerClient<SellerGetPayload<T>>>

    /**
     * Delete zero or more Sellers.
     * @param {SellerDeleteManyArgs} args - Arguments to filter Sellers to delete.
     * @example
     * // Delete a few Sellers
     * const { count } = await prisma.seller.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SellerDeleteManyArgs>(
      args?: SelectSubset<T, SellerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sellers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sellers
     * const seller = await prisma.seller.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SellerUpdateManyArgs>(
      args: SelectSubset<T, SellerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Seller.
     * @param {SellerUpsertArgs} args - Arguments to update or create a Seller.
     * @example
     * // Update or create a Seller
     * const seller = await prisma.seller.upsert({
     *   create: {
     *     // ... data to create a Seller
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seller we want to update
     *   }
     * })
    **/
    upsert<T extends SellerUpsertArgs>(
      args: SelectSubset<T, SellerUpsertArgs>
    ): CheckSelect<T, Prisma__SellerClient<Seller>, Prisma__SellerClient<SellerGetPayload<T>>>

    /**
     * Count the number of Sellers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerCountArgs} args - Arguments to filter Sellers to count.
     * @example
     * // Count the number of Sellers
     * const count = await prisma.seller.count({
     *   where: {
     *     // ... the filter for the Sellers we want to count
     *   }
     * })
    **/
    count<T extends SellerCountArgs>(
      args?: Subset<T, SellerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seller.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellerAggregateArgs>(args: Subset<T, SellerAggregateArgs>): PrismaPromise<GetSellerAggregateType<T>>

    /**
     * Group by Seller.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellerGroupByArgs['orderBy'] }
        : { orderBy?: SellerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellerGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Seller.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SellerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    socialAccounts<T extends SellerSocialAccountFindManyArgs = {}>(args?: Subset<T, SellerSocialAccountFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SellerSocialAccount>>, PrismaPromise<Array<SellerSocialAccountGetPayload<T>>>>;

    goods<T extends GoodsFindManyArgs = {}>(args?: Subset<T, GoodsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Goods>>, PrismaPromise<Array<GoodsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Seller findUnique
   */
  export type SellerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Seller
     * 
    **/
    select?: SellerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SellerInclude | null
    /**
     * Throw an Error if a Seller can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Seller to fetch.
     * 
    **/
    where: SellerWhereUniqueInput
  }


  /**
   * Seller findFirst
   */
  export type SellerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Seller
     * 
    **/
    select?: SellerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SellerInclude | null
    /**
     * Throw an Error if a Seller can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Seller to fetch.
     * 
    **/
    where?: SellerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sellers to fetch.
     * 
    **/
    orderBy?: Enumerable<SellerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sellers.
     * 
    **/
    cursor?: SellerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sellers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sellers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sellers.
     * 
    **/
    distinct?: Enumerable<SellerScalarFieldEnum>
  }


  /**
   * Seller findMany
   */
  export type SellerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Seller
     * 
    **/
    select?: SellerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SellerInclude | null
    /**
     * Filter, which Sellers to fetch.
     * 
    **/
    where?: SellerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sellers to fetch.
     * 
    **/
    orderBy?: Enumerable<SellerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sellers.
     * 
    **/
    cursor?: SellerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sellers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sellers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SellerScalarFieldEnum>
  }


  /**
   * Seller create
   */
  export type SellerCreateArgs = {
    /**
     * Select specific fields to fetch from the Seller
     * 
    **/
    select?: SellerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SellerInclude | null
    /**
     * The data needed to create a Seller.
     * 
    **/
    data: XOR<SellerCreateInput, SellerUncheckedCreateInput>
  }


  /**
   * Seller createMany
   */
  export type SellerCreateManyArgs = {
    data: Enumerable<SellerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Seller update
   */
  export type SellerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Seller
     * 
    **/
    select?: SellerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SellerInclude | null
    /**
     * The data needed to update a Seller.
     * 
    **/
    data: XOR<SellerUpdateInput, SellerUncheckedUpdateInput>
    /**
     * Choose, which Seller to update.
     * 
    **/
    where: SellerWhereUniqueInput
  }


  /**
   * Seller updateMany
   */
  export type SellerUpdateManyArgs = {
    data: XOR<SellerUpdateManyMutationInput, SellerUncheckedUpdateManyInput>
    where?: SellerWhereInput
  }


  /**
   * Seller upsert
   */
  export type SellerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Seller
     * 
    **/
    select?: SellerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SellerInclude | null
    /**
     * The filter to search for the Seller to update in case it exists.
     * 
    **/
    where: SellerWhereUniqueInput
    /**
     * In case the Seller found by the `where` argument doesn't exist, create a new Seller with this data.
     * 
    **/
    create: XOR<SellerCreateInput, SellerUncheckedCreateInput>
    /**
     * In case the Seller was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SellerUpdateInput, SellerUncheckedUpdateInput>
  }


  /**
   * Seller delete
   */
  export type SellerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Seller
     * 
    **/
    select?: SellerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SellerInclude | null
    /**
     * Filter which Seller to delete.
     * 
    **/
    where: SellerWhereUniqueInput
  }


  /**
   * Seller deleteMany
   */
  export type SellerDeleteManyArgs = {
    where?: SellerWhereInput
  }


  /**
   * Seller without action
   */
  export type SellerArgs = {
    /**
     * Select specific fields to fetch from the Seller
     * 
    **/
    select?: SellerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SellerInclude | null
  }



  /**
   * Model MailVerificationCode
   */


  export type AggregateMailVerificationCode = {
    _count: MailVerificationCodeCountAggregateOutputType | null
    count: MailVerificationCodeCountAggregateOutputType | null
    _avg: MailVerificationCodeAvgAggregateOutputType | null
    avg: MailVerificationCodeAvgAggregateOutputType | null
    _sum: MailVerificationCodeSumAggregateOutputType | null
    sum: MailVerificationCodeSumAggregateOutputType | null
    _min: MailVerificationCodeMinAggregateOutputType | null
    min: MailVerificationCodeMinAggregateOutputType | null
    _max: MailVerificationCodeMaxAggregateOutputType | null
    max: MailVerificationCodeMaxAggregateOutputType | null
  }

  export type MailVerificationCodeAvgAggregateOutputType = {
    id: number | null
  }

  export type MailVerificationCodeSumAggregateOutputType = {
    id: number | null
  }

  export type MailVerificationCodeMinAggregateOutputType = {
    id: number | null
    email: string | null
    verificationCode: string | null
    createDate: Date | null
  }

  export type MailVerificationCodeMaxAggregateOutputType = {
    id: number | null
    email: string | null
    verificationCode: string | null
    createDate: Date | null
  }

  export type MailVerificationCodeCountAggregateOutputType = {
    id: number
    email: number
    verificationCode: number
    createDate: number
    _all: number
  }


  export type MailVerificationCodeAvgAggregateInputType = {
    id?: true
  }

  export type MailVerificationCodeSumAggregateInputType = {
    id?: true
  }

  export type MailVerificationCodeMinAggregateInputType = {
    id?: true
    email?: true
    verificationCode?: true
    createDate?: true
  }

  export type MailVerificationCodeMaxAggregateInputType = {
    id?: true
    email?: true
    verificationCode?: true
    createDate?: true
  }

  export type MailVerificationCodeCountAggregateInputType = {
    id?: true
    email?: true
    verificationCode?: true
    createDate?: true
    _all?: true
  }

  export type MailVerificationCodeAggregateArgs = {
    /**
     * Filter which MailVerificationCode to aggregate.
     * 
    **/
    where?: MailVerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailVerificationCodes to fetch.
     * 
    **/
    orderBy?: Enumerable<MailVerificationCodeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MailVerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailVerificationCodes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailVerificationCodes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MailVerificationCodes
    **/
    _count?: true | MailVerificationCodeCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | MailVerificationCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MailVerificationCodeAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: MailVerificationCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MailVerificationCodeSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: MailVerificationCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MailVerificationCodeMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: MailVerificationCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MailVerificationCodeMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: MailVerificationCodeMaxAggregateInputType
  }

  export type GetMailVerificationCodeAggregateType<T extends MailVerificationCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateMailVerificationCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMailVerificationCode[P]>
      : GetScalarType<T[P], AggregateMailVerificationCode[P]>
  }


    
    
  export type MailVerificationCodeGroupByArgs = {
    where?: MailVerificationCodeWhereInput
    orderBy?: Enumerable<MailVerificationCodeOrderByInput>
    by: Array<MailVerificationCodeScalarFieldEnum>
    having?: MailVerificationCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MailVerificationCodeCountAggregateInputType | true
    _avg?: MailVerificationCodeAvgAggregateInputType
    _sum?: MailVerificationCodeSumAggregateInputType
    _min?: MailVerificationCodeMinAggregateInputType
    _max?: MailVerificationCodeMaxAggregateInputType
  }


  export type MailVerificationCodeGroupByOutputType = {
    id: number
    email: string
    verificationCode: string
    createDate: Date
    _count: MailVerificationCodeCountAggregateOutputType | null
    _avg: MailVerificationCodeAvgAggregateOutputType | null
    _sum: MailVerificationCodeSumAggregateOutputType | null
    _min: MailVerificationCodeMinAggregateOutputType | null
    _max: MailVerificationCodeMaxAggregateOutputType | null
  }

  type GetMailVerificationCodeGroupByPayload<T extends MailVerificationCodeGroupByArgs> = Promise<
    Array<
      PickArray<MailVerificationCodeGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof MailVerificationCodeGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], MailVerificationCodeGroupByOutputType[P]> 
            : GetScalarType<T[P], MailVerificationCodeGroupByOutputType[P]>
        }
      > 
    >


  export type MailVerificationCodeSelect = {
    id?: boolean
    email?: boolean
    verificationCode?: boolean
    createDate?: boolean
  }

  export type MailVerificationCodeGetPayload<
    S extends boolean | null | undefined | MailVerificationCodeArgs,
    U = keyof S
      > = S extends true
        ? MailVerificationCode
    : S extends undefined
    ? never
    : S extends MailVerificationCodeArgs | MailVerificationCodeFindManyArgs
    ?'include' extends U
    ? MailVerificationCode 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MailVerificationCode ?MailVerificationCode [P]
  : 
     never
  } 
    : MailVerificationCode
  : MailVerificationCode


  type MailVerificationCodeCountArgs = Merge<
    Omit<MailVerificationCodeFindManyArgs, 'select' | 'include'> & {
      select?: MailVerificationCodeCountAggregateInputType | true
    }
  >

  export interface MailVerificationCodeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MailVerificationCode that matches the filter.
     * @param {MailVerificationCodeFindUniqueArgs} args - Arguments to find a MailVerificationCode
     * @example
     * // Get one MailVerificationCode
     * const mailVerificationCode = await prisma.mailVerificationCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MailVerificationCodeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MailVerificationCodeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MailVerificationCode'> extends True ? CheckSelect<T, Prisma__MailVerificationCodeClient<MailVerificationCode>, Prisma__MailVerificationCodeClient<MailVerificationCodeGetPayload<T>>> : CheckSelect<T, Prisma__MailVerificationCodeClient<MailVerificationCode | null >, Prisma__MailVerificationCodeClient<MailVerificationCodeGetPayload<T> | null >>

    /**
     * Find the first MailVerificationCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailVerificationCodeFindFirstArgs} args - Arguments to find a MailVerificationCode
     * @example
     * // Get one MailVerificationCode
     * const mailVerificationCode = await prisma.mailVerificationCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MailVerificationCodeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MailVerificationCodeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MailVerificationCode'> extends True ? CheckSelect<T, Prisma__MailVerificationCodeClient<MailVerificationCode>, Prisma__MailVerificationCodeClient<MailVerificationCodeGetPayload<T>>> : CheckSelect<T, Prisma__MailVerificationCodeClient<MailVerificationCode | null >, Prisma__MailVerificationCodeClient<MailVerificationCodeGetPayload<T> | null >>

    /**
     * Find zero or more MailVerificationCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailVerificationCodeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MailVerificationCodes
     * const mailVerificationCodes = await prisma.mailVerificationCode.findMany()
     * 
     * // Get first 10 MailVerificationCodes
     * const mailVerificationCodes = await prisma.mailVerificationCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mailVerificationCodeWithIdOnly = await prisma.mailVerificationCode.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MailVerificationCodeFindManyArgs>(
      args?: SelectSubset<T, MailVerificationCodeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MailVerificationCode>>, PrismaPromise<Array<MailVerificationCodeGetPayload<T>>>>

    /**
     * Create a MailVerificationCode.
     * @param {MailVerificationCodeCreateArgs} args - Arguments to create a MailVerificationCode.
     * @example
     * // Create one MailVerificationCode
     * const MailVerificationCode = await prisma.mailVerificationCode.create({
     *   data: {
     *     // ... data to create a MailVerificationCode
     *   }
     * })
     * 
    **/
    create<T extends MailVerificationCodeCreateArgs>(
      args: SelectSubset<T, MailVerificationCodeCreateArgs>
    ): CheckSelect<T, Prisma__MailVerificationCodeClient<MailVerificationCode>, Prisma__MailVerificationCodeClient<MailVerificationCodeGetPayload<T>>>

    /**
     * Create many MailVerificationCodes.
     *     @param {MailVerificationCodeCreateManyArgs} args - Arguments to create many MailVerificationCodes.
     *     @example
     *     // Create many MailVerificationCodes
     *     const mailVerificationCode = await prisma.mailVerificationCode.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MailVerificationCodeCreateManyArgs>(
      args?: SelectSubset<T, MailVerificationCodeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MailVerificationCode.
     * @param {MailVerificationCodeDeleteArgs} args - Arguments to delete one MailVerificationCode.
     * @example
     * // Delete one MailVerificationCode
     * const MailVerificationCode = await prisma.mailVerificationCode.delete({
     *   where: {
     *     // ... filter to delete one MailVerificationCode
     *   }
     * })
     * 
    **/
    delete<T extends MailVerificationCodeDeleteArgs>(
      args: SelectSubset<T, MailVerificationCodeDeleteArgs>
    ): CheckSelect<T, Prisma__MailVerificationCodeClient<MailVerificationCode>, Prisma__MailVerificationCodeClient<MailVerificationCodeGetPayload<T>>>

    /**
     * Update one MailVerificationCode.
     * @param {MailVerificationCodeUpdateArgs} args - Arguments to update one MailVerificationCode.
     * @example
     * // Update one MailVerificationCode
     * const mailVerificationCode = await prisma.mailVerificationCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MailVerificationCodeUpdateArgs>(
      args: SelectSubset<T, MailVerificationCodeUpdateArgs>
    ): CheckSelect<T, Prisma__MailVerificationCodeClient<MailVerificationCode>, Prisma__MailVerificationCodeClient<MailVerificationCodeGetPayload<T>>>

    /**
     * Delete zero or more MailVerificationCodes.
     * @param {MailVerificationCodeDeleteManyArgs} args - Arguments to filter MailVerificationCodes to delete.
     * @example
     * // Delete a few MailVerificationCodes
     * const { count } = await prisma.mailVerificationCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MailVerificationCodeDeleteManyArgs>(
      args?: SelectSubset<T, MailVerificationCodeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MailVerificationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailVerificationCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MailVerificationCodes
     * const mailVerificationCode = await prisma.mailVerificationCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MailVerificationCodeUpdateManyArgs>(
      args: SelectSubset<T, MailVerificationCodeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MailVerificationCode.
     * @param {MailVerificationCodeUpsertArgs} args - Arguments to update or create a MailVerificationCode.
     * @example
     * // Update or create a MailVerificationCode
     * const mailVerificationCode = await prisma.mailVerificationCode.upsert({
     *   create: {
     *     // ... data to create a MailVerificationCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MailVerificationCode we want to update
     *   }
     * })
    **/
    upsert<T extends MailVerificationCodeUpsertArgs>(
      args: SelectSubset<T, MailVerificationCodeUpsertArgs>
    ): CheckSelect<T, Prisma__MailVerificationCodeClient<MailVerificationCode>, Prisma__MailVerificationCodeClient<MailVerificationCodeGetPayload<T>>>

    /**
     * Count the number of MailVerificationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailVerificationCodeCountArgs} args - Arguments to filter MailVerificationCodes to count.
     * @example
     * // Count the number of MailVerificationCodes
     * const count = await prisma.mailVerificationCode.count({
     *   where: {
     *     // ... the filter for the MailVerificationCodes we want to count
     *   }
     * })
    **/
    count<T extends MailVerificationCodeCountArgs>(
      args?: Subset<T, MailVerificationCodeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MailVerificationCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MailVerificationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailVerificationCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MailVerificationCodeAggregateArgs>(args: Subset<T, MailVerificationCodeAggregateArgs>): PrismaPromise<GetMailVerificationCodeAggregateType<T>>

    /**
     * Group by MailVerificationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailVerificationCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MailVerificationCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MailVerificationCodeGroupByArgs['orderBy'] }
        : { orderBy?: MailVerificationCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MailVerificationCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMailVerificationCodeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MailVerificationCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MailVerificationCodeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MailVerificationCode findUnique
   */
  export type MailVerificationCodeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MailVerificationCode
     * 
    **/
    select?: MailVerificationCodeSelect | null
    /**
     * Throw an Error if a MailVerificationCode can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MailVerificationCode to fetch.
     * 
    **/
    where: MailVerificationCodeWhereUniqueInput
  }


  /**
   * MailVerificationCode findFirst
   */
  export type MailVerificationCodeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MailVerificationCode
     * 
    **/
    select?: MailVerificationCodeSelect | null
    /**
     * Throw an Error if a MailVerificationCode can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MailVerificationCode to fetch.
     * 
    **/
    where?: MailVerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailVerificationCodes to fetch.
     * 
    **/
    orderBy?: Enumerable<MailVerificationCodeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MailVerificationCodes.
     * 
    **/
    cursor?: MailVerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailVerificationCodes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailVerificationCodes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MailVerificationCodes.
     * 
    **/
    distinct?: Enumerable<MailVerificationCodeScalarFieldEnum>
  }


  /**
   * MailVerificationCode findMany
   */
  export type MailVerificationCodeFindManyArgs = {
    /**
     * Select specific fields to fetch from the MailVerificationCode
     * 
    **/
    select?: MailVerificationCodeSelect | null
    /**
     * Filter, which MailVerificationCodes to fetch.
     * 
    **/
    where?: MailVerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailVerificationCodes to fetch.
     * 
    **/
    orderBy?: Enumerable<MailVerificationCodeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MailVerificationCodes.
     * 
    **/
    cursor?: MailVerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailVerificationCodes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailVerificationCodes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MailVerificationCodeScalarFieldEnum>
  }


  /**
   * MailVerificationCode create
   */
  export type MailVerificationCodeCreateArgs = {
    /**
     * Select specific fields to fetch from the MailVerificationCode
     * 
    **/
    select?: MailVerificationCodeSelect | null
    /**
     * The data needed to create a MailVerificationCode.
     * 
    **/
    data: XOR<MailVerificationCodeCreateInput, MailVerificationCodeUncheckedCreateInput>
  }


  /**
   * MailVerificationCode createMany
   */
  export type MailVerificationCodeCreateManyArgs = {
    data: Enumerable<MailVerificationCodeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MailVerificationCode update
   */
  export type MailVerificationCodeUpdateArgs = {
    /**
     * Select specific fields to fetch from the MailVerificationCode
     * 
    **/
    select?: MailVerificationCodeSelect | null
    /**
     * The data needed to update a MailVerificationCode.
     * 
    **/
    data: XOR<MailVerificationCodeUpdateInput, MailVerificationCodeUncheckedUpdateInput>
    /**
     * Choose, which MailVerificationCode to update.
     * 
    **/
    where: MailVerificationCodeWhereUniqueInput
  }


  /**
   * MailVerificationCode updateMany
   */
  export type MailVerificationCodeUpdateManyArgs = {
    data: XOR<MailVerificationCodeUpdateManyMutationInput, MailVerificationCodeUncheckedUpdateManyInput>
    where?: MailVerificationCodeWhereInput
  }


  /**
   * MailVerificationCode upsert
   */
  export type MailVerificationCodeUpsertArgs = {
    /**
     * Select specific fields to fetch from the MailVerificationCode
     * 
    **/
    select?: MailVerificationCodeSelect | null
    /**
     * The filter to search for the MailVerificationCode to update in case it exists.
     * 
    **/
    where: MailVerificationCodeWhereUniqueInput
    /**
     * In case the MailVerificationCode found by the `where` argument doesn't exist, create a new MailVerificationCode with this data.
     * 
    **/
    create: XOR<MailVerificationCodeCreateInput, MailVerificationCodeUncheckedCreateInput>
    /**
     * In case the MailVerificationCode was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MailVerificationCodeUpdateInput, MailVerificationCodeUncheckedUpdateInput>
  }


  /**
   * MailVerificationCode delete
   */
  export type MailVerificationCodeDeleteArgs = {
    /**
     * Select specific fields to fetch from the MailVerificationCode
     * 
    **/
    select?: MailVerificationCodeSelect | null
    /**
     * Filter which MailVerificationCode to delete.
     * 
    **/
    where: MailVerificationCodeWhereUniqueInput
  }


  /**
   * MailVerificationCode deleteMany
   */
  export type MailVerificationCodeDeleteManyArgs = {
    where?: MailVerificationCodeWhereInput
  }


  /**
   * MailVerificationCode without action
   */
  export type MailVerificationCodeArgs = {
    /**
     * Select specific fields to fetch from the MailVerificationCode
     * 
    **/
    select?: MailVerificationCodeSelect | null
  }



  /**
   * Model SellerSocialAccount
   */


  export type AggregateSellerSocialAccount = {
    _count: SellerSocialAccountCountAggregateOutputType | null
    count: SellerSocialAccountCountAggregateOutputType | null
    _avg: SellerSocialAccountAvgAggregateOutputType | null
    avg: SellerSocialAccountAvgAggregateOutputType | null
    _sum: SellerSocialAccountSumAggregateOutputType | null
    sum: SellerSocialAccountSumAggregateOutputType | null
    _min: SellerSocialAccountMinAggregateOutputType | null
    min: SellerSocialAccountMinAggregateOutputType | null
    _max: SellerSocialAccountMaxAggregateOutputType | null
    max: SellerSocialAccountMaxAggregateOutputType | null
  }

  export type SellerSocialAccountAvgAggregateOutputType = {
    sellerId: number | null
  }

  export type SellerSocialAccountSumAggregateOutputType = {
    sellerId: number | null
  }

  export type SellerSocialAccountMinAggregateOutputType = {
    serviceId: string | null
    provider: string | null
    name: string | null
    registDate: Date | null
    profileImage: string | null
    accessToken: string | null
    refreshToken: string | null
    sellerId: number | null
  }

  export type SellerSocialAccountMaxAggregateOutputType = {
    serviceId: string | null
    provider: string | null
    name: string | null
    registDate: Date | null
    profileImage: string | null
    accessToken: string | null
    refreshToken: string | null
    sellerId: number | null
  }

  export type SellerSocialAccountCountAggregateOutputType = {
    serviceId: number
    provider: number
    name: number
    registDate: number
    profileImage: number
    accessToken: number
    refreshToken: number
    sellerId: number
    _all: number
  }


  export type SellerSocialAccountAvgAggregateInputType = {
    sellerId?: true
  }

  export type SellerSocialAccountSumAggregateInputType = {
    sellerId?: true
  }

  export type SellerSocialAccountMinAggregateInputType = {
    serviceId?: true
    provider?: true
    name?: true
    registDate?: true
    profileImage?: true
    accessToken?: true
    refreshToken?: true
    sellerId?: true
  }

  export type SellerSocialAccountMaxAggregateInputType = {
    serviceId?: true
    provider?: true
    name?: true
    registDate?: true
    profileImage?: true
    accessToken?: true
    refreshToken?: true
    sellerId?: true
  }

  export type SellerSocialAccountCountAggregateInputType = {
    serviceId?: true
    provider?: true
    name?: true
    registDate?: true
    profileImage?: true
    accessToken?: true
    refreshToken?: true
    sellerId?: true
    _all?: true
  }

  export type SellerSocialAccountAggregateArgs = {
    /**
     * Filter which SellerSocialAccount to aggregate.
     * 
    **/
    where?: SellerSocialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerSocialAccounts to fetch.
     * 
    **/
    orderBy?: Enumerable<SellerSocialAccountOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SellerSocialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerSocialAccounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerSocialAccounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellerSocialAccounts
    **/
    _count?: true | SellerSocialAccountCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | SellerSocialAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellerSocialAccountAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: SellerSocialAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellerSocialAccountSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: SellerSocialAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellerSocialAccountMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: SellerSocialAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellerSocialAccountMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: SellerSocialAccountMaxAggregateInputType
  }

  export type GetSellerSocialAccountAggregateType<T extends SellerSocialAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateSellerSocialAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellerSocialAccount[P]>
      : GetScalarType<T[P], AggregateSellerSocialAccount[P]>
  }


    
    
  export type SellerSocialAccountGroupByArgs = {
    where?: SellerSocialAccountWhereInput
    orderBy?: Enumerable<SellerSocialAccountOrderByInput>
    by: Array<SellerSocialAccountScalarFieldEnum>
    having?: SellerSocialAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellerSocialAccountCountAggregateInputType | true
    _avg?: SellerSocialAccountAvgAggregateInputType
    _sum?: SellerSocialAccountSumAggregateInputType
    _min?: SellerSocialAccountMinAggregateInputType
    _max?: SellerSocialAccountMaxAggregateInputType
  }


  export type SellerSocialAccountGroupByOutputType = {
    serviceId: string
    provider: string
    name: string
    registDate: Date
    profileImage: string | null
    accessToken: string | null
    refreshToken: string | null
    sellerId: number
    _count: SellerSocialAccountCountAggregateOutputType | null
    _avg: SellerSocialAccountAvgAggregateOutputType | null
    _sum: SellerSocialAccountSumAggregateOutputType | null
    _min: SellerSocialAccountMinAggregateOutputType | null
    _max: SellerSocialAccountMaxAggregateOutputType | null
  }

  type GetSellerSocialAccountGroupByPayload<T extends SellerSocialAccountGroupByArgs> = Promise<
    Array<
      PickArray<SellerSocialAccountGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof SellerSocialAccountGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], SellerSocialAccountGroupByOutputType[P]> 
            : GetScalarType<T[P], SellerSocialAccountGroupByOutputType[P]>
        }
      > 
    >


  export type SellerSocialAccountSelect = {
    serviceId?: boolean
    provider?: boolean
    name?: boolean
    registDate?: boolean
    profileImage?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    seller?: boolean | SellerArgs
    sellerId?: boolean
  }

  export type SellerSocialAccountInclude = {
    seller?: boolean | SellerArgs
  }

  export type SellerSocialAccountGetPayload<
    S extends boolean | null | undefined | SellerSocialAccountArgs,
    U = keyof S
      > = S extends true
        ? SellerSocialAccount
    : S extends undefined
    ? never
    : S extends SellerSocialAccountArgs | SellerSocialAccountFindManyArgs
    ?'include' extends U
    ? SellerSocialAccount  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'seller'
        ? SellerGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SellerSocialAccount ?SellerSocialAccount [P]
  : 
          P extends 'seller'
        ? SellerGetPayload<S['select'][P]> : never
  } 
    : SellerSocialAccount
  : SellerSocialAccount


  type SellerSocialAccountCountArgs = Merge<
    Omit<SellerSocialAccountFindManyArgs, 'select' | 'include'> & {
      select?: SellerSocialAccountCountAggregateInputType | true
    }
  >

  export interface SellerSocialAccountDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SellerSocialAccount that matches the filter.
     * @param {SellerSocialAccountFindUniqueArgs} args - Arguments to find a SellerSocialAccount
     * @example
     * // Get one SellerSocialAccount
     * const sellerSocialAccount = await prisma.sellerSocialAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SellerSocialAccountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SellerSocialAccountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SellerSocialAccount'> extends True ? CheckSelect<T, Prisma__SellerSocialAccountClient<SellerSocialAccount>, Prisma__SellerSocialAccountClient<SellerSocialAccountGetPayload<T>>> : CheckSelect<T, Prisma__SellerSocialAccountClient<SellerSocialAccount | null >, Prisma__SellerSocialAccountClient<SellerSocialAccountGetPayload<T> | null >>

    /**
     * Find the first SellerSocialAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerSocialAccountFindFirstArgs} args - Arguments to find a SellerSocialAccount
     * @example
     * // Get one SellerSocialAccount
     * const sellerSocialAccount = await prisma.sellerSocialAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SellerSocialAccountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SellerSocialAccountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SellerSocialAccount'> extends True ? CheckSelect<T, Prisma__SellerSocialAccountClient<SellerSocialAccount>, Prisma__SellerSocialAccountClient<SellerSocialAccountGetPayload<T>>> : CheckSelect<T, Prisma__SellerSocialAccountClient<SellerSocialAccount | null >, Prisma__SellerSocialAccountClient<SellerSocialAccountGetPayload<T> | null >>

    /**
     * Find zero or more SellerSocialAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerSocialAccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellerSocialAccounts
     * const sellerSocialAccounts = await prisma.sellerSocialAccount.findMany()
     * 
     * // Get first 10 SellerSocialAccounts
     * const sellerSocialAccounts = await prisma.sellerSocialAccount.findMany({ take: 10 })
     * 
     * // Only select the `serviceId`
     * const sellerSocialAccountWithServiceIdOnly = await prisma.sellerSocialAccount.findMany({ select: { serviceId: true } })
     * 
    **/
    findMany<T extends SellerSocialAccountFindManyArgs>(
      args?: SelectSubset<T, SellerSocialAccountFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SellerSocialAccount>>, PrismaPromise<Array<SellerSocialAccountGetPayload<T>>>>

    /**
     * Create a SellerSocialAccount.
     * @param {SellerSocialAccountCreateArgs} args - Arguments to create a SellerSocialAccount.
     * @example
     * // Create one SellerSocialAccount
     * const SellerSocialAccount = await prisma.sellerSocialAccount.create({
     *   data: {
     *     // ... data to create a SellerSocialAccount
     *   }
     * })
     * 
    **/
    create<T extends SellerSocialAccountCreateArgs>(
      args: SelectSubset<T, SellerSocialAccountCreateArgs>
    ): CheckSelect<T, Prisma__SellerSocialAccountClient<SellerSocialAccount>, Prisma__SellerSocialAccountClient<SellerSocialAccountGetPayload<T>>>

    /**
     * Create many SellerSocialAccounts.
     *     @param {SellerSocialAccountCreateManyArgs} args - Arguments to create many SellerSocialAccounts.
     *     @example
     *     // Create many SellerSocialAccounts
     *     const sellerSocialAccount = await prisma.sellerSocialAccount.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SellerSocialAccountCreateManyArgs>(
      args?: SelectSubset<T, SellerSocialAccountCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SellerSocialAccount.
     * @param {SellerSocialAccountDeleteArgs} args - Arguments to delete one SellerSocialAccount.
     * @example
     * // Delete one SellerSocialAccount
     * const SellerSocialAccount = await prisma.sellerSocialAccount.delete({
     *   where: {
     *     // ... filter to delete one SellerSocialAccount
     *   }
     * })
     * 
    **/
    delete<T extends SellerSocialAccountDeleteArgs>(
      args: SelectSubset<T, SellerSocialAccountDeleteArgs>
    ): CheckSelect<T, Prisma__SellerSocialAccountClient<SellerSocialAccount>, Prisma__SellerSocialAccountClient<SellerSocialAccountGetPayload<T>>>

    /**
     * Update one SellerSocialAccount.
     * @param {SellerSocialAccountUpdateArgs} args - Arguments to update one SellerSocialAccount.
     * @example
     * // Update one SellerSocialAccount
     * const sellerSocialAccount = await prisma.sellerSocialAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SellerSocialAccountUpdateArgs>(
      args: SelectSubset<T, SellerSocialAccountUpdateArgs>
    ): CheckSelect<T, Prisma__SellerSocialAccountClient<SellerSocialAccount>, Prisma__SellerSocialAccountClient<SellerSocialAccountGetPayload<T>>>

    /**
     * Delete zero or more SellerSocialAccounts.
     * @param {SellerSocialAccountDeleteManyArgs} args - Arguments to filter SellerSocialAccounts to delete.
     * @example
     * // Delete a few SellerSocialAccounts
     * const { count } = await prisma.sellerSocialAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SellerSocialAccountDeleteManyArgs>(
      args?: SelectSubset<T, SellerSocialAccountDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellerSocialAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerSocialAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellerSocialAccounts
     * const sellerSocialAccount = await prisma.sellerSocialAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SellerSocialAccountUpdateManyArgs>(
      args: SelectSubset<T, SellerSocialAccountUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SellerSocialAccount.
     * @param {SellerSocialAccountUpsertArgs} args - Arguments to update or create a SellerSocialAccount.
     * @example
     * // Update or create a SellerSocialAccount
     * const sellerSocialAccount = await prisma.sellerSocialAccount.upsert({
     *   create: {
     *     // ... data to create a SellerSocialAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellerSocialAccount we want to update
     *   }
     * })
    **/
    upsert<T extends SellerSocialAccountUpsertArgs>(
      args: SelectSubset<T, SellerSocialAccountUpsertArgs>
    ): CheckSelect<T, Prisma__SellerSocialAccountClient<SellerSocialAccount>, Prisma__SellerSocialAccountClient<SellerSocialAccountGetPayload<T>>>

    /**
     * Count the number of SellerSocialAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerSocialAccountCountArgs} args - Arguments to filter SellerSocialAccounts to count.
     * @example
     * // Count the number of SellerSocialAccounts
     * const count = await prisma.sellerSocialAccount.count({
     *   where: {
     *     // ... the filter for the SellerSocialAccounts we want to count
     *   }
     * })
    **/
    count<T extends SellerSocialAccountCountArgs>(
      args?: Subset<T, SellerSocialAccountCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellerSocialAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellerSocialAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerSocialAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellerSocialAccountAggregateArgs>(args: Subset<T, SellerSocialAccountAggregateArgs>): PrismaPromise<GetSellerSocialAccountAggregateType<T>>

    /**
     * Group by SellerSocialAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerSocialAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellerSocialAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellerSocialAccountGroupByArgs['orderBy'] }
        : { orderBy?: SellerSocialAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellerSocialAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellerSocialAccountGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellerSocialAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SellerSocialAccountClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    seller<T extends SellerArgs = {}>(args?: Subset<T, SellerArgs>): CheckSelect<T, Prisma__SellerClient<Seller | null >, Prisma__SellerClient<SellerGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SellerSocialAccount findUnique
   */
  export type SellerSocialAccountFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SellerSocialAccount
     * 
    **/
    select?: SellerSocialAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SellerSocialAccountInclude | null
    /**
     * Throw an Error if a SellerSocialAccount can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SellerSocialAccount to fetch.
     * 
    **/
    where: SellerSocialAccountWhereUniqueInput
  }


  /**
   * SellerSocialAccount findFirst
   */
  export type SellerSocialAccountFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SellerSocialAccount
     * 
    **/
    select?: SellerSocialAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SellerSocialAccountInclude | null
    /**
     * Throw an Error if a SellerSocialAccount can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SellerSocialAccount to fetch.
     * 
    **/
    where?: SellerSocialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerSocialAccounts to fetch.
     * 
    **/
    orderBy?: Enumerable<SellerSocialAccountOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerSocialAccounts.
     * 
    **/
    cursor?: SellerSocialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerSocialAccounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerSocialAccounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerSocialAccounts.
     * 
    **/
    distinct?: Enumerable<SellerSocialAccountScalarFieldEnum>
  }


  /**
   * SellerSocialAccount findMany
   */
  export type SellerSocialAccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the SellerSocialAccount
     * 
    **/
    select?: SellerSocialAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SellerSocialAccountInclude | null
    /**
     * Filter, which SellerSocialAccounts to fetch.
     * 
    **/
    where?: SellerSocialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerSocialAccounts to fetch.
     * 
    **/
    orderBy?: Enumerable<SellerSocialAccountOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellerSocialAccounts.
     * 
    **/
    cursor?: SellerSocialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerSocialAccounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerSocialAccounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SellerSocialAccountScalarFieldEnum>
  }


  /**
   * SellerSocialAccount create
   */
  export type SellerSocialAccountCreateArgs = {
    /**
     * Select specific fields to fetch from the SellerSocialAccount
     * 
    **/
    select?: SellerSocialAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SellerSocialAccountInclude | null
    /**
     * The data needed to create a SellerSocialAccount.
     * 
    **/
    data: XOR<SellerSocialAccountCreateInput, SellerSocialAccountUncheckedCreateInput>
  }


  /**
   * SellerSocialAccount createMany
   */
  export type SellerSocialAccountCreateManyArgs = {
    data: Enumerable<SellerSocialAccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SellerSocialAccount update
   */
  export type SellerSocialAccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the SellerSocialAccount
     * 
    **/
    select?: SellerSocialAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SellerSocialAccountInclude | null
    /**
     * The data needed to update a SellerSocialAccount.
     * 
    **/
    data: XOR<SellerSocialAccountUpdateInput, SellerSocialAccountUncheckedUpdateInput>
    /**
     * Choose, which SellerSocialAccount to update.
     * 
    **/
    where: SellerSocialAccountWhereUniqueInput
  }


  /**
   * SellerSocialAccount updateMany
   */
  export type SellerSocialAccountUpdateManyArgs = {
    data: XOR<SellerSocialAccountUpdateManyMutationInput, SellerSocialAccountUncheckedUpdateManyInput>
    where?: SellerSocialAccountWhereInput
  }


  /**
   * SellerSocialAccount upsert
   */
  export type SellerSocialAccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the SellerSocialAccount
     * 
    **/
    select?: SellerSocialAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SellerSocialAccountInclude | null
    /**
     * The filter to search for the SellerSocialAccount to update in case it exists.
     * 
    **/
    where: SellerSocialAccountWhereUniqueInput
    /**
     * In case the SellerSocialAccount found by the `where` argument doesn't exist, create a new SellerSocialAccount with this data.
     * 
    **/
    create: XOR<SellerSocialAccountCreateInput, SellerSocialAccountUncheckedCreateInput>
    /**
     * In case the SellerSocialAccount was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SellerSocialAccountUpdateInput, SellerSocialAccountUncheckedUpdateInput>
  }


  /**
   * SellerSocialAccount delete
   */
  export type SellerSocialAccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the SellerSocialAccount
     * 
    **/
    select?: SellerSocialAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SellerSocialAccountInclude | null
    /**
     * Filter which SellerSocialAccount to delete.
     * 
    **/
    where: SellerSocialAccountWhereUniqueInput
  }


  /**
   * SellerSocialAccount deleteMany
   */
  export type SellerSocialAccountDeleteManyArgs = {
    where?: SellerSocialAccountWhereInput
  }


  /**
   * SellerSocialAccount without action
   */
  export type SellerSocialAccountArgs = {
    /**
     * Select specific fields to fetch from the SellerSocialAccount
     * 
    **/
    select?: SellerSocialAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SellerSocialAccountInclude | null
  }



  /**
   * Model Goods
   */


  export type AggregateGoods = {
    _count: GoodsCountAggregateOutputType | null
    count: GoodsCountAggregateOutputType | null
    _avg: GoodsAvgAggregateOutputType | null
    avg: GoodsAvgAggregateOutputType | null
    _sum: GoodsSumAggregateOutputType | null
    sum: GoodsSumAggregateOutputType | null
    _min: GoodsMinAggregateOutputType | null
    min: GoodsMinAggregateOutputType | null
    _max: GoodsMaxAggregateOutputType | null
    max: GoodsMaxAggregateOutputType | null
  }

  export type GoodsAvgAggregateOutputType = {
    id: number | null
    sellerId: number | null
    unlimit_shipping_price: number | null
    limit_shipping_ea: number | null
    limit_shipping_price: number | null
    limit_shipping_subprice: number | null
    min_purchase_ea: number | null
    max_purchase_ea: number | null
    max_urchase_order_limit: number | null
  }

  export type GoodsSumAggregateOutputType = {
    id: number | null
    sellerId: number | null
    unlimit_shipping_price: number | null
    limit_shipping_ea: number | null
    limit_shipping_price: number | null
    limit_shipping_subprice: number | null
    min_purchase_ea: number | null
    max_purchase_ea: number | null
    max_urchase_order_limit: number | null
  }

  export type GoodsMinAggregateOutputType = {
    id: number | null
    sellerId: number | null
    goods_name: string | null
    summary: string | null
    goods_status: GoodsStatus | null
    cancel_type: string | null
    contents: string | null
    contents_mobile: string | null
    common_contents: string | null
    shipping_policy: ShopOrGoods | null
    goods_shipping_policy: LimitOrUnlimit | null
    unlimit_shipping_price: number | null
    limit_shipping_ea: number | null
    limit_shipping_price: number | null
    limit_shipping_subprice: number | null
    shipping_weight_policy: ShopOrGoods | null
    min_purchase_limit: LimitOrUnlimit | null
    min_purchase_ea: number | null
    max_purchase_limit: LimitOrUnlimit | null
    max_purchase_ea: number | null
    max_urchase_order_limit: number | null
    admin_memo: string | null
    option_use: string | null
    option_view_type: OptionViewType | null
    option_suboption_use: string | null
    member_input_use: string | null
    image: string | null
  }

  export type GoodsMaxAggregateOutputType = {
    id: number | null
    sellerId: number | null
    goods_name: string | null
    summary: string | null
    goods_status: GoodsStatus | null
    cancel_type: string | null
    contents: string | null
    contents_mobile: string | null
    common_contents: string | null
    shipping_policy: ShopOrGoods | null
    goods_shipping_policy: LimitOrUnlimit | null
    unlimit_shipping_price: number | null
    limit_shipping_ea: number | null
    limit_shipping_price: number | null
    limit_shipping_subprice: number | null
    shipping_weight_policy: ShopOrGoods | null
    min_purchase_limit: LimitOrUnlimit | null
    min_purchase_ea: number | null
    max_purchase_limit: LimitOrUnlimit | null
    max_purchase_ea: number | null
    max_urchase_order_limit: number | null
    admin_memo: string | null
    option_use: string | null
    option_view_type: OptionViewType | null
    option_suboption_use: string | null
    member_input_use: string | null
    image: string | null
  }

  export type GoodsCountAggregateOutputType = {
    id: number
    sellerId: number
    goods_name: number
    summary: number
    goods_status: number
    cancel_type: number
    contents: number
    contents_mobile: number
    common_contents: number
    shipping_policy: number
    goods_shipping_policy: number
    unlimit_shipping_price: number
    limit_shipping_ea: number
    limit_shipping_price: number
    limit_shipping_subprice: number
    shipping_weight_policy: number
    min_purchase_limit: number
    min_purchase_ea: number
    max_purchase_limit: number
    max_purchase_ea: number
    max_urchase_order_limit: number
    admin_memo: number
    option_use: number
    option_view_type: number
    option_suboption_use: number
    member_input_use: number
    image: number
    _all: number
  }


  export type GoodsAvgAggregateInputType = {
    id?: true
    sellerId?: true
    unlimit_shipping_price?: true
    limit_shipping_ea?: true
    limit_shipping_price?: true
    limit_shipping_subprice?: true
    min_purchase_ea?: true
    max_purchase_ea?: true
    max_urchase_order_limit?: true
  }

  export type GoodsSumAggregateInputType = {
    id?: true
    sellerId?: true
    unlimit_shipping_price?: true
    limit_shipping_ea?: true
    limit_shipping_price?: true
    limit_shipping_subprice?: true
    min_purchase_ea?: true
    max_purchase_ea?: true
    max_urchase_order_limit?: true
  }

  export type GoodsMinAggregateInputType = {
    id?: true
    sellerId?: true
    goods_name?: true
    summary?: true
    goods_status?: true
    cancel_type?: true
    contents?: true
    contents_mobile?: true
    common_contents?: true
    shipping_policy?: true
    goods_shipping_policy?: true
    unlimit_shipping_price?: true
    limit_shipping_ea?: true
    limit_shipping_price?: true
    limit_shipping_subprice?: true
    shipping_weight_policy?: true
    min_purchase_limit?: true
    min_purchase_ea?: true
    max_purchase_limit?: true
    max_purchase_ea?: true
    max_urchase_order_limit?: true
    admin_memo?: true
    option_use?: true
    option_view_type?: true
    option_suboption_use?: true
    member_input_use?: true
    image?: true
  }

  export type GoodsMaxAggregateInputType = {
    id?: true
    sellerId?: true
    goods_name?: true
    summary?: true
    goods_status?: true
    cancel_type?: true
    contents?: true
    contents_mobile?: true
    common_contents?: true
    shipping_policy?: true
    goods_shipping_policy?: true
    unlimit_shipping_price?: true
    limit_shipping_ea?: true
    limit_shipping_price?: true
    limit_shipping_subprice?: true
    shipping_weight_policy?: true
    min_purchase_limit?: true
    min_purchase_ea?: true
    max_purchase_limit?: true
    max_purchase_ea?: true
    max_urchase_order_limit?: true
    admin_memo?: true
    option_use?: true
    option_view_type?: true
    option_suboption_use?: true
    member_input_use?: true
    image?: true
  }

  export type GoodsCountAggregateInputType = {
    id?: true
    sellerId?: true
    goods_name?: true
    summary?: true
    goods_status?: true
    cancel_type?: true
    contents?: true
    contents_mobile?: true
    common_contents?: true
    shipping_policy?: true
    goods_shipping_policy?: true
    unlimit_shipping_price?: true
    limit_shipping_ea?: true
    limit_shipping_price?: true
    limit_shipping_subprice?: true
    shipping_weight_policy?: true
    min_purchase_limit?: true
    min_purchase_ea?: true
    max_purchase_limit?: true
    max_purchase_ea?: true
    max_urchase_order_limit?: true
    admin_memo?: true
    option_use?: true
    option_view_type?: true
    option_suboption_use?: true
    member_input_use?: true
    image?: true
    _all?: true
  }

  export type GoodsAggregateArgs = {
    /**
     * Filter which Goods to aggregate.
     * 
    **/
    where?: GoodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goods to fetch.
     * 
    **/
    orderBy?: Enumerable<GoodsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GoodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goods from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goods.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Goods
    **/
    _count?: true | GoodsCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | GoodsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoodsAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: GoodsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoodsSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: GoodsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoodsMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: GoodsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoodsMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: GoodsMaxAggregateInputType
  }

  export type GetGoodsAggregateType<T extends GoodsAggregateArgs> = {
        [P in keyof T & keyof AggregateGoods]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoods[P]>
      : GetScalarType<T[P], AggregateGoods[P]>
  }


    
    
  export type GoodsGroupByArgs = {
    where?: GoodsWhereInput
    orderBy?: Enumerable<GoodsOrderByInput>
    by: Array<GoodsScalarFieldEnum>
    having?: GoodsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoodsCountAggregateInputType | true
    _avg?: GoodsAvgAggregateInputType
    _sum?: GoodsSumAggregateInputType
    _min?: GoodsMinAggregateInputType
    _max?: GoodsMaxAggregateInputType
  }


  export type GoodsGroupByOutputType = {
    id: number
    sellerId: number
    goods_name: string
    summary: string
    goods_status: GoodsStatus
    cancel_type: string
    contents: string | null
    contents_mobile: string | null
    common_contents: string
    shipping_policy: ShopOrGoods
    goods_shipping_policy: LimitOrUnlimit
    unlimit_shipping_price: number | null
    limit_shipping_ea: number | null
    limit_shipping_price: number | null
    limit_shipping_subprice: number | null
    shipping_weight_policy: ShopOrGoods
    min_purchase_limit: LimitOrUnlimit
    min_purchase_ea: number | null
    max_purchase_limit: LimitOrUnlimit
    max_purchase_ea: number | null
    max_urchase_order_limit: number | null
    admin_memo: string | null
    option_use: string
    option_view_type: OptionViewType
    option_suboption_use: string
    member_input_use: string
    image: string
    _count: GoodsCountAggregateOutputType | null
    _avg: GoodsAvgAggregateOutputType | null
    _sum: GoodsSumAggregateOutputType | null
    _min: GoodsMinAggregateOutputType | null
    _max: GoodsMaxAggregateOutputType | null
  }

  type GetGoodsGroupByPayload<T extends GoodsGroupByArgs> = Promise<
    Array<
      PickArray<GoodsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof GoodsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], GoodsGroupByOutputType[P]> 
            : GetScalarType<T[P], GoodsGroupByOutputType[P]>
        }
      > 
    >


  export type GoodsSelect = {
    id?: boolean
    sellerId?: boolean
    seller?: boolean | SellerArgs
    options?: boolean | GoodsOptionsFindManyArgs
    confirmation?: boolean | GoodsConfirmationArgs
    goods_name?: boolean
    summary?: boolean
    goods_status?: boolean
    cancel_type?: boolean
    contents?: boolean
    contents_mobile?: boolean
    common_contents?: boolean
    shipping_policy?: boolean
    goods_shipping_policy?: boolean
    unlimit_shipping_price?: boolean
    limit_shipping_ea?: boolean
    limit_shipping_price?: boolean
    limit_shipping_subprice?: boolean
    shipping_weight_policy?: boolean
    min_purchase_limit?: boolean
    min_purchase_ea?: boolean
    max_purchase_limit?: boolean
    max_purchase_ea?: boolean
    max_urchase_order_limit?: boolean
    admin_memo?: boolean
    option_use?: boolean
    option_view_type?: boolean
    option_suboption_use?: boolean
    member_input_use?: boolean
    image?: boolean
  }

  export type GoodsInclude = {
    seller?: boolean | SellerArgs
    options?: boolean | GoodsOptionsFindManyArgs
    confirmation?: boolean | GoodsConfirmationArgs
  }

  export type GoodsGetPayload<
    S extends boolean | null | undefined | GoodsArgs,
    U = keyof S
      > = S extends true
        ? Goods
    : S extends undefined
    ? never
    : S extends GoodsArgs | GoodsFindManyArgs
    ?'include' extends U
    ? Goods  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'seller'
        ? SellerGetPayload<S['include'][P]> :
        P extends 'options'
        ? Array < GoodsOptionsGetPayload<S['include'][P]>>  :
        P extends 'confirmation'
        ? GoodsConfirmationGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Goods ?Goods [P]
  : 
          P extends 'seller'
        ? SellerGetPayload<S['select'][P]> :
        P extends 'options'
        ? Array < GoodsOptionsGetPayload<S['select'][P]>>  :
        P extends 'confirmation'
        ? GoodsConfirmationGetPayload<S['select'][P]> | null : never
  } 
    : Goods
  : Goods


  type GoodsCountArgs = Merge<
    Omit<GoodsFindManyArgs, 'select' | 'include'> & {
      select?: GoodsCountAggregateInputType | true
    }
  >

  export interface GoodsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Goods that matches the filter.
     * @param {GoodsFindUniqueArgs} args - Arguments to find a Goods
     * @example
     * // Get one Goods
     * const goods = await prisma.goods.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GoodsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GoodsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Goods'> extends True ? CheckSelect<T, Prisma__GoodsClient<Goods>, Prisma__GoodsClient<GoodsGetPayload<T>>> : CheckSelect<T, Prisma__GoodsClient<Goods | null >, Prisma__GoodsClient<GoodsGetPayload<T> | null >>

    /**
     * Find the first Goods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsFindFirstArgs} args - Arguments to find a Goods
     * @example
     * // Get one Goods
     * const goods = await prisma.goods.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GoodsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GoodsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Goods'> extends True ? CheckSelect<T, Prisma__GoodsClient<Goods>, Prisma__GoodsClient<GoodsGetPayload<T>>> : CheckSelect<T, Prisma__GoodsClient<Goods | null >, Prisma__GoodsClient<GoodsGetPayload<T> | null >>

    /**
     * Find zero or more Goods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Goods
     * const goods = await prisma.goods.findMany()
     * 
     * // Get first 10 Goods
     * const goods = await prisma.goods.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goodsWithIdOnly = await prisma.goods.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GoodsFindManyArgs>(
      args?: SelectSubset<T, GoodsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Goods>>, PrismaPromise<Array<GoodsGetPayload<T>>>>

    /**
     * Create a Goods.
     * @param {GoodsCreateArgs} args - Arguments to create a Goods.
     * @example
     * // Create one Goods
     * const Goods = await prisma.goods.create({
     *   data: {
     *     // ... data to create a Goods
     *   }
     * })
     * 
    **/
    create<T extends GoodsCreateArgs>(
      args: SelectSubset<T, GoodsCreateArgs>
    ): CheckSelect<T, Prisma__GoodsClient<Goods>, Prisma__GoodsClient<GoodsGetPayload<T>>>

    /**
     * Create many Goods.
     *     @param {GoodsCreateManyArgs} args - Arguments to create many Goods.
     *     @example
     *     // Create many Goods
     *     const goods = await prisma.goods.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GoodsCreateManyArgs>(
      args?: SelectSubset<T, GoodsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Goods.
     * @param {GoodsDeleteArgs} args - Arguments to delete one Goods.
     * @example
     * // Delete one Goods
     * const Goods = await prisma.goods.delete({
     *   where: {
     *     // ... filter to delete one Goods
     *   }
     * })
     * 
    **/
    delete<T extends GoodsDeleteArgs>(
      args: SelectSubset<T, GoodsDeleteArgs>
    ): CheckSelect<T, Prisma__GoodsClient<Goods>, Prisma__GoodsClient<GoodsGetPayload<T>>>

    /**
     * Update one Goods.
     * @param {GoodsUpdateArgs} args - Arguments to update one Goods.
     * @example
     * // Update one Goods
     * const goods = await prisma.goods.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GoodsUpdateArgs>(
      args: SelectSubset<T, GoodsUpdateArgs>
    ): CheckSelect<T, Prisma__GoodsClient<Goods>, Prisma__GoodsClient<GoodsGetPayload<T>>>

    /**
     * Delete zero or more Goods.
     * @param {GoodsDeleteManyArgs} args - Arguments to filter Goods to delete.
     * @example
     * // Delete a few Goods
     * const { count } = await prisma.goods.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GoodsDeleteManyArgs>(
      args?: SelectSubset<T, GoodsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Goods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Goods
     * const goods = await prisma.goods.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GoodsUpdateManyArgs>(
      args: SelectSubset<T, GoodsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Goods.
     * @param {GoodsUpsertArgs} args - Arguments to update or create a Goods.
     * @example
     * // Update or create a Goods
     * const goods = await prisma.goods.upsert({
     *   create: {
     *     // ... data to create a Goods
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Goods we want to update
     *   }
     * })
    **/
    upsert<T extends GoodsUpsertArgs>(
      args: SelectSubset<T, GoodsUpsertArgs>
    ): CheckSelect<T, Prisma__GoodsClient<Goods>, Prisma__GoodsClient<GoodsGetPayload<T>>>

    /**
     * Count the number of Goods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsCountArgs} args - Arguments to filter Goods to count.
     * @example
     * // Count the number of Goods
     * const count = await prisma.goods.count({
     *   where: {
     *     // ... the filter for the Goods we want to count
     *   }
     * })
    **/
    count<T extends GoodsCountArgs>(
      args?: Subset<T, GoodsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoodsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Goods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoodsAggregateArgs>(args: Subset<T, GoodsAggregateArgs>): PrismaPromise<GetGoodsAggregateType<T>>

    /**
     * Group by Goods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoodsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoodsGroupByArgs['orderBy'] }
        : { orderBy?: GoodsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoodsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoodsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Goods.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GoodsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    seller<T extends SellerArgs = {}>(args?: Subset<T, SellerArgs>): CheckSelect<T, Prisma__SellerClient<Seller | null >, Prisma__SellerClient<SellerGetPayload<T> | null >>;

    options<T extends GoodsOptionsFindManyArgs = {}>(args?: Subset<T, GoodsOptionsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<GoodsOptions>>, PrismaPromise<Array<GoodsOptionsGetPayload<T>>>>;

    confirmation<T extends GoodsConfirmationArgs = {}>(args?: Subset<T, GoodsConfirmationArgs>): CheckSelect<T, Prisma__GoodsConfirmationClient<GoodsConfirmation | null >, Prisma__GoodsConfirmationClient<GoodsConfirmationGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Goods findUnique
   */
  export type GoodsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Goods
     * 
    **/
    select?: GoodsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsInclude | null
    /**
     * Throw an Error if a Goods can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Goods to fetch.
     * 
    **/
    where: GoodsWhereUniqueInput
  }


  /**
   * Goods findFirst
   */
  export type GoodsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Goods
     * 
    **/
    select?: GoodsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsInclude | null
    /**
     * Throw an Error if a Goods can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Goods to fetch.
     * 
    **/
    where?: GoodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goods to fetch.
     * 
    **/
    orderBy?: Enumerable<GoodsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goods.
     * 
    **/
    cursor?: GoodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goods from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goods.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goods.
     * 
    **/
    distinct?: Enumerable<GoodsScalarFieldEnum>
  }


  /**
   * Goods findMany
   */
  export type GoodsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Goods
     * 
    **/
    select?: GoodsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsInclude | null
    /**
     * Filter, which Goods to fetch.
     * 
    **/
    where?: GoodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goods to fetch.
     * 
    **/
    orderBy?: Enumerable<GoodsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Goods.
     * 
    **/
    cursor?: GoodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goods from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goods.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GoodsScalarFieldEnum>
  }


  /**
   * Goods create
   */
  export type GoodsCreateArgs = {
    /**
     * Select specific fields to fetch from the Goods
     * 
    **/
    select?: GoodsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsInclude | null
    /**
     * The data needed to create a Goods.
     * 
    **/
    data: XOR<GoodsCreateInput, GoodsUncheckedCreateInput>
  }


  /**
   * Goods createMany
   */
  export type GoodsCreateManyArgs = {
    data: Enumerable<GoodsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Goods update
   */
  export type GoodsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Goods
     * 
    **/
    select?: GoodsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsInclude | null
    /**
     * The data needed to update a Goods.
     * 
    **/
    data: XOR<GoodsUpdateInput, GoodsUncheckedUpdateInput>
    /**
     * Choose, which Goods to update.
     * 
    **/
    where: GoodsWhereUniqueInput
  }


  /**
   * Goods updateMany
   */
  export type GoodsUpdateManyArgs = {
    data: XOR<GoodsUpdateManyMutationInput, GoodsUncheckedUpdateManyInput>
    where?: GoodsWhereInput
  }


  /**
   * Goods upsert
   */
  export type GoodsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Goods
     * 
    **/
    select?: GoodsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsInclude | null
    /**
     * The filter to search for the Goods to update in case it exists.
     * 
    **/
    where: GoodsWhereUniqueInput
    /**
     * In case the Goods found by the `where` argument doesn't exist, create a new Goods with this data.
     * 
    **/
    create: XOR<GoodsCreateInput, GoodsUncheckedCreateInput>
    /**
     * In case the Goods was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GoodsUpdateInput, GoodsUncheckedUpdateInput>
  }


  /**
   * Goods delete
   */
  export type GoodsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Goods
     * 
    **/
    select?: GoodsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsInclude | null
    /**
     * Filter which Goods to delete.
     * 
    **/
    where: GoodsWhereUniqueInput
  }


  /**
   * Goods deleteMany
   */
  export type GoodsDeleteManyArgs = {
    where?: GoodsWhereInput
  }


  /**
   * Goods without action
   */
  export type GoodsArgs = {
    /**
     * Select specific fields to fetch from the Goods
     * 
    **/
    select?: GoodsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsInclude | null
  }



  /**
   * Model GoodsConfirmation
   */


  export type AggregateGoodsConfirmation = {
    _count: GoodsConfirmationCountAggregateOutputType | null
    count: GoodsConfirmationCountAggregateOutputType | null
    _avg: GoodsConfirmationAvgAggregateOutputType | null
    avg: GoodsConfirmationAvgAggregateOutputType | null
    _sum: GoodsConfirmationSumAggregateOutputType | null
    sum: GoodsConfirmationSumAggregateOutputType | null
    _min: GoodsConfirmationMinAggregateOutputType | null
    min: GoodsConfirmationMinAggregateOutputType | null
    _max: GoodsConfirmationMaxAggregateOutputType | null
    max: GoodsConfirmationMaxAggregateOutputType | null
  }

  export type GoodsConfirmationAvgAggregateOutputType = {
    id: number | null
    goodsId: number | null
    firstmallGoodsConnectionId: number | null
  }

  export type GoodsConfirmationSumAggregateOutputType = {
    id: number | null
    goodsId: number | null
    firstmallGoodsConnectionId: number | null
  }

  export type GoodsConfirmationMinAggregateOutputType = {
    id: number | null
    goodsId: number | null
    status: GoodsConfirmationStatuses | null
    firstmallGoodsConnectionId: number | null
  }

  export type GoodsConfirmationMaxAggregateOutputType = {
    id: number | null
    goodsId: number | null
    status: GoodsConfirmationStatuses | null
    firstmallGoodsConnectionId: number | null
  }

  export type GoodsConfirmationCountAggregateOutputType = {
    id: number
    goodsId: number
    status: number
    firstmallGoodsConnectionId: number
    _all: number
  }


  export type GoodsConfirmationAvgAggregateInputType = {
    id?: true
    goodsId?: true
    firstmallGoodsConnectionId?: true
  }

  export type GoodsConfirmationSumAggregateInputType = {
    id?: true
    goodsId?: true
    firstmallGoodsConnectionId?: true
  }

  export type GoodsConfirmationMinAggregateInputType = {
    id?: true
    goodsId?: true
    status?: true
    firstmallGoodsConnectionId?: true
  }

  export type GoodsConfirmationMaxAggregateInputType = {
    id?: true
    goodsId?: true
    status?: true
    firstmallGoodsConnectionId?: true
  }

  export type GoodsConfirmationCountAggregateInputType = {
    id?: true
    goodsId?: true
    status?: true
    firstmallGoodsConnectionId?: true
    _all?: true
  }

  export type GoodsConfirmationAggregateArgs = {
    /**
     * Filter which GoodsConfirmation to aggregate.
     * 
    **/
    where?: GoodsConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoodsConfirmations to fetch.
     * 
    **/
    orderBy?: Enumerable<GoodsConfirmationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GoodsConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoodsConfirmations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoodsConfirmations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoodsConfirmations
    **/
    _count?: true | GoodsConfirmationCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | GoodsConfirmationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoodsConfirmationAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: GoodsConfirmationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoodsConfirmationSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: GoodsConfirmationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoodsConfirmationMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: GoodsConfirmationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoodsConfirmationMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: GoodsConfirmationMaxAggregateInputType
  }

  export type GetGoodsConfirmationAggregateType<T extends GoodsConfirmationAggregateArgs> = {
        [P in keyof T & keyof AggregateGoodsConfirmation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoodsConfirmation[P]>
      : GetScalarType<T[P], AggregateGoodsConfirmation[P]>
  }


    
    
  export type GoodsConfirmationGroupByArgs = {
    where?: GoodsConfirmationWhereInput
    orderBy?: Enumerable<GoodsConfirmationOrderByInput>
    by: Array<GoodsConfirmationScalarFieldEnum>
    having?: GoodsConfirmationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoodsConfirmationCountAggregateInputType | true
    _avg?: GoodsConfirmationAvgAggregateInputType
    _sum?: GoodsConfirmationSumAggregateInputType
    _min?: GoodsConfirmationMinAggregateInputType
    _max?: GoodsConfirmationMaxAggregateInputType
  }


  export type GoodsConfirmationGroupByOutputType = {
    id: number
    goodsId: number
    status: GoodsConfirmationStatuses
    firstmallGoodsConnectionId: number | null
    _count: GoodsConfirmationCountAggregateOutputType | null
    _avg: GoodsConfirmationAvgAggregateOutputType | null
    _sum: GoodsConfirmationSumAggregateOutputType | null
    _min: GoodsConfirmationMinAggregateOutputType | null
    _max: GoodsConfirmationMaxAggregateOutputType | null
  }

  type GetGoodsConfirmationGroupByPayload<T extends GoodsConfirmationGroupByArgs> = Promise<
    Array<
      PickArray<GoodsConfirmationGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof GoodsConfirmationGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], GoodsConfirmationGroupByOutputType[P]> 
            : GetScalarType<T[P], GoodsConfirmationGroupByOutputType[P]>
        }
      > 
    >


  export type GoodsConfirmationSelect = {
    id?: boolean
    goodsId?: boolean
    goods?: boolean | GoodsArgs
    status?: boolean
    firstmallGoodsConnectionId?: boolean
  }

  export type GoodsConfirmationInclude = {
    goods?: boolean | GoodsArgs
  }

  export type GoodsConfirmationGetPayload<
    S extends boolean | null | undefined | GoodsConfirmationArgs,
    U = keyof S
      > = S extends true
        ? GoodsConfirmation
    : S extends undefined
    ? never
    : S extends GoodsConfirmationArgs | GoodsConfirmationFindManyArgs
    ?'include' extends U
    ? GoodsConfirmation  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'goods'
        ? GoodsGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof GoodsConfirmation ?GoodsConfirmation [P]
  : 
          P extends 'goods'
        ? GoodsGetPayload<S['select'][P]> : never
  } 
    : GoodsConfirmation
  : GoodsConfirmation


  type GoodsConfirmationCountArgs = Merge<
    Omit<GoodsConfirmationFindManyArgs, 'select' | 'include'> & {
      select?: GoodsConfirmationCountAggregateInputType | true
    }
  >

  export interface GoodsConfirmationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one GoodsConfirmation that matches the filter.
     * @param {GoodsConfirmationFindUniqueArgs} args - Arguments to find a GoodsConfirmation
     * @example
     * // Get one GoodsConfirmation
     * const goodsConfirmation = await prisma.goodsConfirmation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GoodsConfirmationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GoodsConfirmationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GoodsConfirmation'> extends True ? CheckSelect<T, Prisma__GoodsConfirmationClient<GoodsConfirmation>, Prisma__GoodsConfirmationClient<GoodsConfirmationGetPayload<T>>> : CheckSelect<T, Prisma__GoodsConfirmationClient<GoodsConfirmation | null >, Prisma__GoodsConfirmationClient<GoodsConfirmationGetPayload<T> | null >>

    /**
     * Find the first GoodsConfirmation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsConfirmationFindFirstArgs} args - Arguments to find a GoodsConfirmation
     * @example
     * // Get one GoodsConfirmation
     * const goodsConfirmation = await prisma.goodsConfirmation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GoodsConfirmationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GoodsConfirmationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GoodsConfirmation'> extends True ? CheckSelect<T, Prisma__GoodsConfirmationClient<GoodsConfirmation>, Prisma__GoodsConfirmationClient<GoodsConfirmationGetPayload<T>>> : CheckSelect<T, Prisma__GoodsConfirmationClient<GoodsConfirmation | null >, Prisma__GoodsConfirmationClient<GoodsConfirmationGetPayload<T> | null >>

    /**
     * Find zero or more GoodsConfirmations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsConfirmationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoodsConfirmations
     * const goodsConfirmations = await prisma.goodsConfirmation.findMany()
     * 
     * // Get first 10 GoodsConfirmations
     * const goodsConfirmations = await prisma.goodsConfirmation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goodsConfirmationWithIdOnly = await prisma.goodsConfirmation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GoodsConfirmationFindManyArgs>(
      args?: SelectSubset<T, GoodsConfirmationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<GoodsConfirmation>>, PrismaPromise<Array<GoodsConfirmationGetPayload<T>>>>

    /**
     * Create a GoodsConfirmation.
     * @param {GoodsConfirmationCreateArgs} args - Arguments to create a GoodsConfirmation.
     * @example
     * // Create one GoodsConfirmation
     * const GoodsConfirmation = await prisma.goodsConfirmation.create({
     *   data: {
     *     // ... data to create a GoodsConfirmation
     *   }
     * })
     * 
    **/
    create<T extends GoodsConfirmationCreateArgs>(
      args: SelectSubset<T, GoodsConfirmationCreateArgs>
    ): CheckSelect<T, Prisma__GoodsConfirmationClient<GoodsConfirmation>, Prisma__GoodsConfirmationClient<GoodsConfirmationGetPayload<T>>>

    /**
     * Create many GoodsConfirmations.
     *     @param {GoodsConfirmationCreateManyArgs} args - Arguments to create many GoodsConfirmations.
     *     @example
     *     // Create many GoodsConfirmations
     *     const goodsConfirmation = await prisma.goodsConfirmation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GoodsConfirmationCreateManyArgs>(
      args?: SelectSubset<T, GoodsConfirmationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a GoodsConfirmation.
     * @param {GoodsConfirmationDeleteArgs} args - Arguments to delete one GoodsConfirmation.
     * @example
     * // Delete one GoodsConfirmation
     * const GoodsConfirmation = await prisma.goodsConfirmation.delete({
     *   where: {
     *     // ... filter to delete one GoodsConfirmation
     *   }
     * })
     * 
    **/
    delete<T extends GoodsConfirmationDeleteArgs>(
      args: SelectSubset<T, GoodsConfirmationDeleteArgs>
    ): CheckSelect<T, Prisma__GoodsConfirmationClient<GoodsConfirmation>, Prisma__GoodsConfirmationClient<GoodsConfirmationGetPayload<T>>>

    /**
     * Update one GoodsConfirmation.
     * @param {GoodsConfirmationUpdateArgs} args - Arguments to update one GoodsConfirmation.
     * @example
     * // Update one GoodsConfirmation
     * const goodsConfirmation = await prisma.goodsConfirmation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GoodsConfirmationUpdateArgs>(
      args: SelectSubset<T, GoodsConfirmationUpdateArgs>
    ): CheckSelect<T, Prisma__GoodsConfirmationClient<GoodsConfirmation>, Prisma__GoodsConfirmationClient<GoodsConfirmationGetPayload<T>>>

    /**
     * Delete zero or more GoodsConfirmations.
     * @param {GoodsConfirmationDeleteManyArgs} args - Arguments to filter GoodsConfirmations to delete.
     * @example
     * // Delete a few GoodsConfirmations
     * const { count } = await prisma.goodsConfirmation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GoodsConfirmationDeleteManyArgs>(
      args?: SelectSubset<T, GoodsConfirmationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoodsConfirmations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsConfirmationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoodsConfirmations
     * const goodsConfirmation = await prisma.goodsConfirmation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GoodsConfirmationUpdateManyArgs>(
      args: SelectSubset<T, GoodsConfirmationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one GoodsConfirmation.
     * @param {GoodsConfirmationUpsertArgs} args - Arguments to update or create a GoodsConfirmation.
     * @example
     * // Update or create a GoodsConfirmation
     * const goodsConfirmation = await prisma.goodsConfirmation.upsert({
     *   create: {
     *     // ... data to create a GoodsConfirmation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoodsConfirmation we want to update
     *   }
     * })
    **/
    upsert<T extends GoodsConfirmationUpsertArgs>(
      args: SelectSubset<T, GoodsConfirmationUpsertArgs>
    ): CheckSelect<T, Prisma__GoodsConfirmationClient<GoodsConfirmation>, Prisma__GoodsConfirmationClient<GoodsConfirmationGetPayload<T>>>

    /**
     * Count the number of GoodsConfirmations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsConfirmationCountArgs} args - Arguments to filter GoodsConfirmations to count.
     * @example
     * // Count the number of GoodsConfirmations
     * const count = await prisma.goodsConfirmation.count({
     *   where: {
     *     // ... the filter for the GoodsConfirmations we want to count
     *   }
     * })
    **/
    count<T extends GoodsConfirmationCountArgs>(
      args?: Subset<T, GoodsConfirmationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoodsConfirmationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoodsConfirmation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsConfirmationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoodsConfirmationAggregateArgs>(args: Subset<T, GoodsConfirmationAggregateArgs>): PrismaPromise<GetGoodsConfirmationAggregateType<T>>

    /**
     * Group by GoodsConfirmation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsConfirmationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoodsConfirmationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoodsConfirmationGroupByArgs['orderBy'] }
        : { orderBy?: GoodsConfirmationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoodsConfirmationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoodsConfirmationGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for GoodsConfirmation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GoodsConfirmationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    goods<T extends GoodsArgs = {}>(args?: Subset<T, GoodsArgs>): CheckSelect<T, Prisma__GoodsClient<Goods | null >, Prisma__GoodsClient<GoodsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * GoodsConfirmation findUnique
   */
  export type GoodsConfirmationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the GoodsConfirmation
     * 
    **/
    select?: GoodsConfirmationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsConfirmationInclude | null
    /**
     * Throw an Error if a GoodsConfirmation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GoodsConfirmation to fetch.
     * 
    **/
    where: GoodsConfirmationWhereUniqueInput
  }


  /**
   * GoodsConfirmation findFirst
   */
  export type GoodsConfirmationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the GoodsConfirmation
     * 
    **/
    select?: GoodsConfirmationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsConfirmationInclude | null
    /**
     * Throw an Error if a GoodsConfirmation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GoodsConfirmation to fetch.
     * 
    **/
    where?: GoodsConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoodsConfirmations to fetch.
     * 
    **/
    orderBy?: Enumerable<GoodsConfirmationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoodsConfirmations.
     * 
    **/
    cursor?: GoodsConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoodsConfirmations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoodsConfirmations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoodsConfirmations.
     * 
    **/
    distinct?: Enumerable<GoodsConfirmationScalarFieldEnum>
  }


  /**
   * GoodsConfirmation findMany
   */
  export type GoodsConfirmationFindManyArgs = {
    /**
     * Select specific fields to fetch from the GoodsConfirmation
     * 
    **/
    select?: GoodsConfirmationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsConfirmationInclude | null
    /**
     * Filter, which GoodsConfirmations to fetch.
     * 
    **/
    where?: GoodsConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoodsConfirmations to fetch.
     * 
    **/
    orderBy?: Enumerable<GoodsConfirmationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoodsConfirmations.
     * 
    **/
    cursor?: GoodsConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoodsConfirmations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoodsConfirmations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GoodsConfirmationScalarFieldEnum>
  }


  /**
   * GoodsConfirmation create
   */
  export type GoodsConfirmationCreateArgs = {
    /**
     * Select specific fields to fetch from the GoodsConfirmation
     * 
    **/
    select?: GoodsConfirmationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsConfirmationInclude | null
    /**
     * The data needed to create a GoodsConfirmation.
     * 
    **/
    data: XOR<GoodsConfirmationCreateInput, GoodsConfirmationUncheckedCreateInput>
  }


  /**
   * GoodsConfirmation createMany
   */
  export type GoodsConfirmationCreateManyArgs = {
    data: Enumerable<GoodsConfirmationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GoodsConfirmation update
   */
  export type GoodsConfirmationUpdateArgs = {
    /**
     * Select specific fields to fetch from the GoodsConfirmation
     * 
    **/
    select?: GoodsConfirmationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsConfirmationInclude | null
    /**
     * The data needed to update a GoodsConfirmation.
     * 
    **/
    data: XOR<GoodsConfirmationUpdateInput, GoodsConfirmationUncheckedUpdateInput>
    /**
     * Choose, which GoodsConfirmation to update.
     * 
    **/
    where: GoodsConfirmationWhereUniqueInput
  }


  /**
   * GoodsConfirmation updateMany
   */
  export type GoodsConfirmationUpdateManyArgs = {
    data: XOR<GoodsConfirmationUpdateManyMutationInput, GoodsConfirmationUncheckedUpdateManyInput>
    where?: GoodsConfirmationWhereInput
  }


  /**
   * GoodsConfirmation upsert
   */
  export type GoodsConfirmationUpsertArgs = {
    /**
     * Select specific fields to fetch from the GoodsConfirmation
     * 
    **/
    select?: GoodsConfirmationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsConfirmationInclude | null
    /**
     * The filter to search for the GoodsConfirmation to update in case it exists.
     * 
    **/
    where: GoodsConfirmationWhereUniqueInput
    /**
     * In case the GoodsConfirmation found by the `where` argument doesn't exist, create a new GoodsConfirmation with this data.
     * 
    **/
    create: XOR<GoodsConfirmationCreateInput, GoodsConfirmationUncheckedCreateInput>
    /**
     * In case the GoodsConfirmation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GoodsConfirmationUpdateInput, GoodsConfirmationUncheckedUpdateInput>
  }


  /**
   * GoodsConfirmation delete
   */
  export type GoodsConfirmationDeleteArgs = {
    /**
     * Select specific fields to fetch from the GoodsConfirmation
     * 
    **/
    select?: GoodsConfirmationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsConfirmationInclude | null
    /**
     * Filter which GoodsConfirmation to delete.
     * 
    **/
    where: GoodsConfirmationWhereUniqueInput
  }


  /**
   * GoodsConfirmation deleteMany
   */
  export type GoodsConfirmationDeleteManyArgs = {
    where?: GoodsConfirmationWhereInput
  }


  /**
   * GoodsConfirmation without action
   */
  export type GoodsConfirmationArgs = {
    /**
     * Select specific fields to fetch from the GoodsConfirmation
     * 
    **/
    select?: GoodsConfirmationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsConfirmationInclude | null
  }



  /**
   * Model GoodsOptions
   */


  export type AggregateGoodsOptions = {
    _count: GoodsOptionsCountAggregateOutputType | null
    count: GoodsOptionsCountAggregateOutputType | null
    _avg: GoodsOptionsAvgAggregateOutputType | null
    avg: GoodsOptionsAvgAggregateOutputType | null
    _sum: GoodsOptionsSumAggregateOutputType | null
    sum: GoodsOptionsSumAggregateOutputType | null
    _min: GoodsOptionsMinAggregateOutputType | null
    min: GoodsOptionsMinAggregateOutputType | null
    _max: GoodsOptionsMaxAggregateOutputType | null
    max: GoodsOptionsMaxAggregateOutputType | null
  }

  export type GoodsOptionsAvgAggregateOutputType = {
    id: number | null
    goodsId: number | null
    consumer_price: Decimal | null
    price: Decimal | null
    weight: number | null
  }

  export type GoodsOptionsSumAggregateOutputType = {
    id: number | null
    goodsId: number | null
    consumer_price: Decimal | null
    price: Decimal | null
    weight: number | null
  }

  export type GoodsOptionsMinAggregateOutputType = {
    id: number | null
    goodsId: number | null
    default_option: YesOrNo | null
    option_type: string | null
    option_title: string | null
    option_code: string | null
    consumer_price: Decimal | null
    price: Decimal | null
    color: string | null
    weight: number | null
    option_view: YesOrNo_UPPERCASE | null
  }

  export type GoodsOptionsMaxAggregateOutputType = {
    id: number | null
    goodsId: number | null
    default_option: YesOrNo | null
    option_type: string | null
    option_title: string | null
    option_code: string | null
    consumer_price: Decimal | null
    price: Decimal | null
    color: string | null
    weight: number | null
    option_view: YesOrNo_UPPERCASE | null
  }

  export type GoodsOptionsCountAggregateOutputType = {
    id: number
    goodsId: number
    default_option: number
    option_type: number
    option_title: number
    option_code: number
    consumer_price: number
    price: number
    color: number
    weight: number
    option_view: number
    _all: number
  }


  export type GoodsOptionsAvgAggregateInputType = {
    id?: true
    goodsId?: true
    consumer_price?: true
    price?: true
    weight?: true
  }

  export type GoodsOptionsSumAggregateInputType = {
    id?: true
    goodsId?: true
    consumer_price?: true
    price?: true
    weight?: true
  }

  export type GoodsOptionsMinAggregateInputType = {
    id?: true
    goodsId?: true
    default_option?: true
    option_type?: true
    option_title?: true
    option_code?: true
    consumer_price?: true
    price?: true
    color?: true
    weight?: true
    option_view?: true
  }

  export type GoodsOptionsMaxAggregateInputType = {
    id?: true
    goodsId?: true
    default_option?: true
    option_type?: true
    option_title?: true
    option_code?: true
    consumer_price?: true
    price?: true
    color?: true
    weight?: true
    option_view?: true
  }

  export type GoodsOptionsCountAggregateInputType = {
    id?: true
    goodsId?: true
    default_option?: true
    option_type?: true
    option_title?: true
    option_code?: true
    consumer_price?: true
    price?: true
    color?: true
    weight?: true
    option_view?: true
    _all?: true
  }

  export type GoodsOptionsAggregateArgs = {
    /**
     * Filter which GoodsOptions to aggregate.
     * 
    **/
    where?: GoodsOptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoodsOptions to fetch.
     * 
    **/
    orderBy?: Enumerable<GoodsOptionsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GoodsOptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoodsOptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoodsOptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoodsOptions
    **/
    _count?: true | GoodsOptionsCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | GoodsOptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoodsOptionsAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: GoodsOptionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoodsOptionsSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: GoodsOptionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoodsOptionsMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: GoodsOptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoodsOptionsMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: GoodsOptionsMaxAggregateInputType
  }

  export type GetGoodsOptionsAggregateType<T extends GoodsOptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateGoodsOptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoodsOptions[P]>
      : GetScalarType<T[P], AggregateGoodsOptions[P]>
  }


    
    
  export type GoodsOptionsGroupByArgs = {
    where?: GoodsOptionsWhereInput
    orderBy?: Enumerable<GoodsOptionsOrderByInput>
    by: Array<GoodsOptionsScalarFieldEnum>
    having?: GoodsOptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoodsOptionsCountAggregateInputType | true
    _avg?: GoodsOptionsAvgAggregateInputType
    _sum?: GoodsOptionsSumAggregateInputType
    _min?: GoodsOptionsMinAggregateInputType
    _max?: GoodsOptionsMaxAggregateInputType
  }


  export type GoodsOptionsGroupByOutputType = {
    id: number
    goodsId: number
    default_option: YesOrNo
    option_type: string
    option_title: string | null
    option_code: string | null
    consumer_price: Decimal
    price: Decimal
    color: string | null
    weight: number | null
    option_view: YesOrNo_UPPERCASE
    _count: GoodsOptionsCountAggregateOutputType | null
    _avg: GoodsOptionsAvgAggregateOutputType | null
    _sum: GoodsOptionsSumAggregateOutputType | null
    _min: GoodsOptionsMinAggregateOutputType | null
    _max: GoodsOptionsMaxAggregateOutputType | null
  }

  type GetGoodsOptionsGroupByPayload<T extends GoodsOptionsGroupByArgs> = Promise<
    Array<
      PickArray<GoodsOptionsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof GoodsOptionsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], GoodsOptionsGroupByOutputType[P]> 
            : GetScalarType<T[P], GoodsOptionsGroupByOutputType[P]>
        }
      > 
    >


  export type GoodsOptionsSelect = {
    id?: boolean
    goods?: boolean | GoodsArgs
    goodsId?: boolean
    supply?: boolean | GoodsOptionsSuppliesFindManyArgs
    default_option?: boolean
    option_type?: boolean
    option_title?: boolean
    option_code?: boolean
    consumer_price?: boolean
    price?: boolean
    color?: boolean
    weight?: boolean
    option_view?: boolean
  }

  export type GoodsOptionsInclude = {
    goods?: boolean | GoodsArgs
    supply?: boolean | GoodsOptionsSuppliesFindManyArgs
  }

  export type GoodsOptionsGetPayload<
    S extends boolean | null | undefined | GoodsOptionsArgs,
    U = keyof S
      > = S extends true
        ? GoodsOptions
    : S extends undefined
    ? never
    : S extends GoodsOptionsArgs | GoodsOptionsFindManyArgs
    ?'include' extends U
    ? GoodsOptions  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'goods'
        ? GoodsGetPayload<S['include'][P]> :
        P extends 'supply'
        ? Array < GoodsOptionsSuppliesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof GoodsOptions ?GoodsOptions [P]
  : 
          P extends 'goods'
        ? GoodsGetPayload<S['select'][P]> :
        P extends 'supply'
        ? Array < GoodsOptionsSuppliesGetPayload<S['select'][P]>>  : never
  } 
    : GoodsOptions
  : GoodsOptions


  type GoodsOptionsCountArgs = Merge<
    Omit<GoodsOptionsFindManyArgs, 'select' | 'include'> & {
      select?: GoodsOptionsCountAggregateInputType | true
    }
  >

  export interface GoodsOptionsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one GoodsOptions that matches the filter.
     * @param {GoodsOptionsFindUniqueArgs} args - Arguments to find a GoodsOptions
     * @example
     * // Get one GoodsOptions
     * const goodsOptions = await prisma.goodsOptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GoodsOptionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GoodsOptionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GoodsOptions'> extends True ? CheckSelect<T, Prisma__GoodsOptionsClient<GoodsOptions>, Prisma__GoodsOptionsClient<GoodsOptionsGetPayload<T>>> : CheckSelect<T, Prisma__GoodsOptionsClient<GoodsOptions | null >, Prisma__GoodsOptionsClient<GoodsOptionsGetPayload<T> | null >>

    /**
     * Find the first GoodsOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsOptionsFindFirstArgs} args - Arguments to find a GoodsOptions
     * @example
     * // Get one GoodsOptions
     * const goodsOptions = await prisma.goodsOptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GoodsOptionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GoodsOptionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GoodsOptions'> extends True ? CheckSelect<T, Prisma__GoodsOptionsClient<GoodsOptions>, Prisma__GoodsOptionsClient<GoodsOptionsGetPayload<T>>> : CheckSelect<T, Prisma__GoodsOptionsClient<GoodsOptions | null >, Prisma__GoodsOptionsClient<GoodsOptionsGetPayload<T> | null >>

    /**
     * Find zero or more GoodsOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsOptionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoodsOptions
     * const goodsOptions = await prisma.goodsOptions.findMany()
     * 
     * // Get first 10 GoodsOptions
     * const goodsOptions = await prisma.goodsOptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goodsOptionsWithIdOnly = await prisma.goodsOptions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GoodsOptionsFindManyArgs>(
      args?: SelectSubset<T, GoodsOptionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<GoodsOptions>>, PrismaPromise<Array<GoodsOptionsGetPayload<T>>>>

    /**
     * Create a GoodsOptions.
     * @param {GoodsOptionsCreateArgs} args - Arguments to create a GoodsOptions.
     * @example
     * // Create one GoodsOptions
     * const GoodsOptions = await prisma.goodsOptions.create({
     *   data: {
     *     // ... data to create a GoodsOptions
     *   }
     * })
     * 
    **/
    create<T extends GoodsOptionsCreateArgs>(
      args: SelectSubset<T, GoodsOptionsCreateArgs>
    ): CheckSelect<T, Prisma__GoodsOptionsClient<GoodsOptions>, Prisma__GoodsOptionsClient<GoodsOptionsGetPayload<T>>>

    /**
     * Create many GoodsOptions.
     *     @param {GoodsOptionsCreateManyArgs} args - Arguments to create many GoodsOptions.
     *     @example
     *     // Create many GoodsOptions
     *     const goodsOptions = await prisma.goodsOptions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GoodsOptionsCreateManyArgs>(
      args?: SelectSubset<T, GoodsOptionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a GoodsOptions.
     * @param {GoodsOptionsDeleteArgs} args - Arguments to delete one GoodsOptions.
     * @example
     * // Delete one GoodsOptions
     * const GoodsOptions = await prisma.goodsOptions.delete({
     *   where: {
     *     // ... filter to delete one GoodsOptions
     *   }
     * })
     * 
    **/
    delete<T extends GoodsOptionsDeleteArgs>(
      args: SelectSubset<T, GoodsOptionsDeleteArgs>
    ): CheckSelect<T, Prisma__GoodsOptionsClient<GoodsOptions>, Prisma__GoodsOptionsClient<GoodsOptionsGetPayload<T>>>

    /**
     * Update one GoodsOptions.
     * @param {GoodsOptionsUpdateArgs} args - Arguments to update one GoodsOptions.
     * @example
     * // Update one GoodsOptions
     * const goodsOptions = await prisma.goodsOptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GoodsOptionsUpdateArgs>(
      args: SelectSubset<T, GoodsOptionsUpdateArgs>
    ): CheckSelect<T, Prisma__GoodsOptionsClient<GoodsOptions>, Prisma__GoodsOptionsClient<GoodsOptionsGetPayload<T>>>

    /**
     * Delete zero or more GoodsOptions.
     * @param {GoodsOptionsDeleteManyArgs} args - Arguments to filter GoodsOptions to delete.
     * @example
     * // Delete a few GoodsOptions
     * const { count } = await prisma.goodsOptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GoodsOptionsDeleteManyArgs>(
      args?: SelectSubset<T, GoodsOptionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoodsOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsOptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoodsOptions
     * const goodsOptions = await prisma.goodsOptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GoodsOptionsUpdateManyArgs>(
      args: SelectSubset<T, GoodsOptionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one GoodsOptions.
     * @param {GoodsOptionsUpsertArgs} args - Arguments to update or create a GoodsOptions.
     * @example
     * // Update or create a GoodsOptions
     * const goodsOptions = await prisma.goodsOptions.upsert({
     *   create: {
     *     // ... data to create a GoodsOptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoodsOptions we want to update
     *   }
     * })
    **/
    upsert<T extends GoodsOptionsUpsertArgs>(
      args: SelectSubset<T, GoodsOptionsUpsertArgs>
    ): CheckSelect<T, Prisma__GoodsOptionsClient<GoodsOptions>, Prisma__GoodsOptionsClient<GoodsOptionsGetPayload<T>>>

    /**
     * Count the number of GoodsOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsOptionsCountArgs} args - Arguments to filter GoodsOptions to count.
     * @example
     * // Count the number of GoodsOptions
     * const count = await prisma.goodsOptions.count({
     *   where: {
     *     // ... the filter for the GoodsOptions we want to count
     *   }
     * })
    **/
    count<T extends GoodsOptionsCountArgs>(
      args?: Subset<T, GoodsOptionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoodsOptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoodsOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsOptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoodsOptionsAggregateArgs>(args: Subset<T, GoodsOptionsAggregateArgs>): PrismaPromise<GetGoodsOptionsAggregateType<T>>

    /**
     * Group by GoodsOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsOptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoodsOptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoodsOptionsGroupByArgs['orderBy'] }
        : { orderBy?: GoodsOptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoodsOptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoodsOptionsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for GoodsOptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GoodsOptionsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    goods<T extends GoodsArgs = {}>(args?: Subset<T, GoodsArgs>): CheckSelect<T, Prisma__GoodsClient<Goods | null >, Prisma__GoodsClient<GoodsGetPayload<T> | null >>;

    supply<T extends GoodsOptionsSuppliesFindManyArgs = {}>(args?: Subset<T, GoodsOptionsSuppliesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<GoodsOptionsSupplies>>, PrismaPromise<Array<GoodsOptionsSuppliesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * GoodsOptions findUnique
   */
  export type GoodsOptionsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the GoodsOptions
     * 
    **/
    select?: GoodsOptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsOptionsInclude | null
    /**
     * Throw an Error if a GoodsOptions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GoodsOptions to fetch.
     * 
    **/
    where: GoodsOptionsWhereUniqueInput
  }


  /**
   * GoodsOptions findFirst
   */
  export type GoodsOptionsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the GoodsOptions
     * 
    **/
    select?: GoodsOptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsOptionsInclude | null
    /**
     * Throw an Error if a GoodsOptions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GoodsOptions to fetch.
     * 
    **/
    where?: GoodsOptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoodsOptions to fetch.
     * 
    **/
    orderBy?: Enumerable<GoodsOptionsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoodsOptions.
     * 
    **/
    cursor?: GoodsOptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoodsOptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoodsOptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoodsOptions.
     * 
    **/
    distinct?: Enumerable<GoodsOptionsScalarFieldEnum>
  }


  /**
   * GoodsOptions findMany
   */
  export type GoodsOptionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the GoodsOptions
     * 
    **/
    select?: GoodsOptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsOptionsInclude | null
    /**
     * Filter, which GoodsOptions to fetch.
     * 
    **/
    where?: GoodsOptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoodsOptions to fetch.
     * 
    **/
    orderBy?: Enumerable<GoodsOptionsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoodsOptions.
     * 
    **/
    cursor?: GoodsOptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoodsOptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoodsOptions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GoodsOptionsScalarFieldEnum>
  }


  /**
   * GoodsOptions create
   */
  export type GoodsOptionsCreateArgs = {
    /**
     * Select specific fields to fetch from the GoodsOptions
     * 
    **/
    select?: GoodsOptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsOptionsInclude | null
    /**
     * The data needed to create a GoodsOptions.
     * 
    **/
    data: XOR<GoodsOptionsCreateInput, GoodsOptionsUncheckedCreateInput>
  }


  /**
   * GoodsOptions createMany
   */
  export type GoodsOptionsCreateManyArgs = {
    data: Enumerable<GoodsOptionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GoodsOptions update
   */
  export type GoodsOptionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the GoodsOptions
     * 
    **/
    select?: GoodsOptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsOptionsInclude | null
    /**
     * The data needed to update a GoodsOptions.
     * 
    **/
    data: XOR<GoodsOptionsUpdateInput, GoodsOptionsUncheckedUpdateInput>
    /**
     * Choose, which GoodsOptions to update.
     * 
    **/
    where: GoodsOptionsWhereUniqueInput
  }


  /**
   * GoodsOptions updateMany
   */
  export type GoodsOptionsUpdateManyArgs = {
    data: XOR<GoodsOptionsUpdateManyMutationInput, GoodsOptionsUncheckedUpdateManyInput>
    where?: GoodsOptionsWhereInput
  }


  /**
   * GoodsOptions upsert
   */
  export type GoodsOptionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the GoodsOptions
     * 
    **/
    select?: GoodsOptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsOptionsInclude | null
    /**
     * The filter to search for the GoodsOptions to update in case it exists.
     * 
    **/
    where: GoodsOptionsWhereUniqueInput
    /**
     * In case the GoodsOptions found by the `where` argument doesn't exist, create a new GoodsOptions with this data.
     * 
    **/
    create: XOR<GoodsOptionsCreateInput, GoodsOptionsUncheckedCreateInput>
    /**
     * In case the GoodsOptions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GoodsOptionsUpdateInput, GoodsOptionsUncheckedUpdateInput>
  }


  /**
   * GoodsOptions delete
   */
  export type GoodsOptionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the GoodsOptions
     * 
    **/
    select?: GoodsOptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsOptionsInclude | null
    /**
     * Filter which GoodsOptions to delete.
     * 
    **/
    where: GoodsOptionsWhereUniqueInput
  }


  /**
   * GoodsOptions deleteMany
   */
  export type GoodsOptionsDeleteManyArgs = {
    where?: GoodsOptionsWhereInput
  }


  /**
   * GoodsOptions without action
   */
  export type GoodsOptionsArgs = {
    /**
     * Select specific fields to fetch from the GoodsOptions
     * 
    **/
    select?: GoodsOptionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsOptionsInclude | null
  }



  /**
   * Model GoodsOptionsSupplies
   */


  export type AggregateGoodsOptionsSupplies = {
    _count: GoodsOptionsSuppliesCountAggregateOutputType | null
    count: GoodsOptionsSuppliesCountAggregateOutputType | null
    _avg: GoodsOptionsSuppliesAvgAggregateOutputType | null
    avg: GoodsOptionsSuppliesAvgAggregateOutputType | null
    _sum: GoodsOptionsSuppliesSumAggregateOutputType | null
    sum: GoodsOptionsSuppliesSumAggregateOutputType | null
    _min: GoodsOptionsSuppliesMinAggregateOutputType | null
    min: GoodsOptionsSuppliesMinAggregateOutputType | null
    _max: GoodsOptionsSuppliesMaxAggregateOutputType | null
    max: GoodsOptionsSuppliesMaxAggregateOutputType | null
  }

  export type GoodsOptionsSuppliesAvgAggregateOutputType = {
    id: number | null
    goodsOptionsId: number | null
    stock: number | null
    badstock: number | null
    safe_stock: number | null
  }

  export type GoodsOptionsSuppliesSumAggregateOutputType = {
    id: number | null
    goodsOptionsId: number | null
    stock: number | null
    badstock: number | null
    safe_stock: number | null
  }

  export type GoodsOptionsSuppliesMinAggregateOutputType = {
    id: number | null
    goodsOptionsId: number | null
    stock: number | null
    badstock: number | null
    safe_stock: number | null
  }

  export type GoodsOptionsSuppliesMaxAggregateOutputType = {
    id: number | null
    goodsOptionsId: number | null
    stock: number | null
    badstock: number | null
    safe_stock: number | null
  }

  export type GoodsOptionsSuppliesCountAggregateOutputType = {
    id: number
    goodsOptionsId: number
    stock: number
    badstock: number
    safe_stock: number
    _all: number
  }


  export type GoodsOptionsSuppliesAvgAggregateInputType = {
    id?: true
    goodsOptionsId?: true
    stock?: true
    badstock?: true
    safe_stock?: true
  }

  export type GoodsOptionsSuppliesSumAggregateInputType = {
    id?: true
    goodsOptionsId?: true
    stock?: true
    badstock?: true
    safe_stock?: true
  }

  export type GoodsOptionsSuppliesMinAggregateInputType = {
    id?: true
    goodsOptionsId?: true
    stock?: true
    badstock?: true
    safe_stock?: true
  }

  export type GoodsOptionsSuppliesMaxAggregateInputType = {
    id?: true
    goodsOptionsId?: true
    stock?: true
    badstock?: true
    safe_stock?: true
  }

  export type GoodsOptionsSuppliesCountAggregateInputType = {
    id?: true
    goodsOptionsId?: true
    stock?: true
    badstock?: true
    safe_stock?: true
    _all?: true
  }

  export type GoodsOptionsSuppliesAggregateArgs = {
    /**
     * Filter which GoodsOptionsSupplies to aggregate.
     * 
    **/
    where?: GoodsOptionsSuppliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoodsOptionsSupplies to fetch.
     * 
    **/
    orderBy?: Enumerable<GoodsOptionsSuppliesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GoodsOptionsSuppliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoodsOptionsSupplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoodsOptionsSupplies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoodsOptionsSupplies
    **/
    _count?: true | GoodsOptionsSuppliesCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | GoodsOptionsSuppliesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoodsOptionsSuppliesAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: GoodsOptionsSuppliesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoodsOptionsSuppliesSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: GoodsOptionsSuppliesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoodsOptionsSuppliesMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: GoodsOptionsSuppliesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoodsOptionsSuppliesMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: GoodsOptionsSuppliesMaxAggregateInputType
  }

  export type GetGoodsOptionsSuppliesAggregateType<T extends GoodsOptionsSuppliesAggregateArgs> = {
        [P in keyof T & keyof AggregateGoodsOptionsSupplies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoodsOptionsSupplies[P]>
      : GetScalarType<T[P], AggregateGoodsOptionsSupplies[P]>
  }


    
    
  export type GoodsOptionsSuppliesGroupByArgs = {
    where?: GoodsOptionsSuppliesWhereInput
    orderBy?: Enumerable<GoodsOptionsSuppliesOrderByInput>
    by: Array<GoodsOptionsSuppliesScalarFieldEnum>
    having?: GoodsOptionsSuppliesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoodsOptionsSuppliesCountAggregateInputType | true
    _avg?: GoodsOptionsSuppliesAvgAggregateInputType
    _sum?: GoodsOptionsSuppliesSumAggregateInputType
    _min?: GoodsOptionsSuppliesMinAggregateInputType
    _max?: GoodsOptionsSuppliesMaxAggregateInputType
  }


  export type GoodsOptionsSuppliesGroupByOutputType = {
    id: number
    goodsOptionsId: number
    stock: number
    badstock: number | null
    safe_stock: number | null
    _count: GoodsOptionsSuppliesCountAggregateOutputType | null
    _avg: GoodsOptionsSuppliesAvgAggregateOutputType | null
    _sum: GoodsOptionsSuppliesSumAggregateOutputType | null
    _min: GoodsOptionsSuppliesMinAggregateOutputType | null
    _max: GoodsOptionsSuppliesMaxAggregateOutputType | null
  }

  type GetGoodsOptionsSuppliesGroupByPayload<T extends GoodsOptionsSuppliesGroupByArgs> = Promise<
    Array<
      PickArray<GoodsOptionsSuppliesGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof GoodsOptionsSuppliesGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], GoodsOptionsSuppliesGroupByOutputType[P]> 
            : GetScalarType<T[P], GoodsOptionsSuppliesGroupByOutputType[P]>
        }
      > 
    >


  export type GoodsOptionsSuppliesSelect = {
    id?: boolean
    goodsOptions?: boolean | GoodsOptionsArgs
    goodsOptionsId?: boolean
    stock?: boolean
    badstock?: boolean
    safe_stock?: boolean
  }

  export type GoodsOptionsSuppliesInclude = {
    goodsOptions?: boolean | GoodsOptionsArgs
  }

  export type GoodsOptionsSuppliesGetPayload<
    S extends boolean | null | undefined | GoodsOptionsSuppliesArgs,
    U = keyof S
      > = S extends true
        ? GoodsOptionsSupplies
    : S extends undefined
    ? never
    : S extends GoodsOptionsSuppliesArgs | GoodsOptionsSuppliesFindManyArgs
    ?'include' extends U
    ? GoodsOptionsSupplies  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'goodsOptions'
        ? GoodsOptionsGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof GoodsOptionsSupplies ?GoodsOptionsSupplies [P]
  : 
          P extends 'goodsOptions'
        ? GoodsOptionsGetPayload<S['select'][P]> : never
  } 
    : GoodsOptionsSupplies
  : GoodsOptionsSupplies


  type GoodsOptionsSuppliesCountArgs = Merge<
    Omit<GoodsOptionsSuppliesFindManyArgs, 'select' | 'include'> & {
      select?: GoodsOptionsSuppliesCountAggregateInputType | true
    }
  >

  export interface GoodsOptionsSuppliesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one GoodsOptionsSupplies that matches the filter.
     * @param {GoodsOptionsSuppliesFindUniqueArgs} args - Arguments to find a GoodsOptionsSupplies
     * @example
     * // Get one GoodsOptionsSupplies
     * const goodsOptionsSupplies = await prisma.goodsOptionsSupplies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GoodsOptionsSuppliesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GoodsOptionsSuppliesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GoodsOptionsSupplies'> extends True ? CheckSelect<T, Prisma__GoodsOptionsSuppliesClient<GoodsOptionsSupplies>, Prisma__GoodsOptionsSuppliesClient<GoodsOptionsSuppliesGetPayload<T>>> : CheckSelect<T, Prisma__GoodsOptionsSuppliesClient<GoodsOptionsSupplies | null >, Prisma__GoodsOptionsSuppliesClient<GoodsOptionsSuppliesGetPayload<T> | null >>

    /**
     * Find the first GoodsOptionsSupplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsOptionsSuppliesFindFirstArgs} args - Arguments to find a GoodsOptionsSupplies
     * @example
     * // Get one GoodsOptionsSupplies
     * const goodsOptionsSupplies = await prisma.goodsOptionsSupplies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GoodsOptionsSuppliesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GoodsOptionsSuppliesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GoodsOptionsSupplies'> extends True ? CheckSelect<T, Prisma__GoodsOptionsSuppliesClient<GoodsOptionsSupplies>, Prisma__GoodsOptionsSuppliesClient<GoodsOptionsSuppliesGetPayload<T>>> : CheckSelect<T, Prisma__GoodsOptionsSuppliesClient<GoodsOptionsSupplies | null >, Prisma__GoodsOptionsSuppliesClient<GoodsOptionsSuppliesGetPayload<T> | null >>

    /**
     * Find zero or more GoodsOptionsSupplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsOptionsSuppliesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoodsOptionsSupplies
     * const goodsOptionsSupplies = await prisma.goodsOptionsSupplies.findMany()
     * 
     * // Get first 10 GoodsOptionsSupplies
     * const goodsOptionsSupplies = await prisma.goodsOptionsSupplies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goodsOptionsSuppliesWithIdOnly = await prisma.goodsOptionsSupplies.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GoodsOptionsSuppliesFindManyArgs>(
      args?: SelectSubset<T, GoodsOptionsSuppliesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<GoodsOptionsSupplies>>, PrismaPromise<Array<GoodsOptionsSuppliesGetPayload<T>>>>

    /**
     * Create a GoodsOptionsSupplies.
     * @param {GoodsOptionsSuppliesCreateArgs} args - Arguments to create a GoodsOptionsSupplies.
     * @example
     * // Create one GoodsOptionsSupplies
     * const GoodsOptionsSupplies = await prisma.goodsOptionsSupplies.create({
     *   data: {
     *     // ... data to create a GoodsOptionsSupplies
     *   }
     * })
     * 
    **/
    create<T extends GoodsOptionsSuppliesCreateArgs>(
      args: SelectSubset<T, GoodsOptionsSuppliesCreateArgs>
    ): CheckSelect<T, Prisma__GoodsOptionsSuppliesClient<GoodsOptionsSupplies>, Prisma__GoodsOptionsSuppliesClient<GoodsOptionsSuppliesGetPayload<T>>>

    /**
     * Create many GoodsOptionsSupplies.
     *     @param {GoodsOptionsSuppliesCreateManyArgs} args - Arguments to create many GoodsOptionsSupplies.
     *     @example
     *     // Create many GoodsOptionsSupplies
     *     const goodsOptionsSupplies = await prisma.goodsOptionsSupplies.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GoodsOptionsSuppliesCreateManyArgs>(
      args?: SelectSubset<T, GoodsOptionsSuppliesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a GoodsOptionsSupplies.
     * @param {GoodsOptionsSuppliesDeleteArgs} args - Arguments to delete one GoodsOptionsSupplies.
     * @example
     * // Delete one GoodsOptionsSupplies
     * const GoodsOptionsSupplies = await prisma.goodsOptionsSupplies.delete({
     *   where: {
     *     // ... filter to delete one GoodsOptionsSupplies
     *   }
     * })
     * 
    **/
    delete<T extends GoodsOptionsSuppliesDeleteArgs>(
      args: SelectSubset<T, GoodsOptionsSuppliesDeleteArgs>
    ): CheckSelect<T, Prisma__GoodsOptionsSuppliesClient<GoodsOptionsSupplies>, Prisma__GoodsOptionsSuppliesClient<GoodsOptionsSuppliesGetPayload<T>>>

    /**
     * Update one GoodsOptionsSupplies.
     * @param {GoodsOptionsSuppliesUpdateArgs} args - Arguments to update one GoodsOptionsSupplies.
     * @example
     * // Update one GoodsOptionsSupplies
     * const goodsOptionsSupplies = await prisma.goodsOptionsSupplies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GoodsOptionsSuppliesUpdateArgs>(
      args: SelectSubset<T, GoodsOptionsSuppliesUpdateArgs>
    ): CheckSelect<T, Prisma__GoodsOptionsSuppliesClient<GoodsOptionsSupplies>, Prisma__GoodsOptionsSuppliesClient<GoodsOptionsSuppliesGetPayload<T>>>

    /**
     * Delete zero or more GoodsOptionsSupplies.
     * @param {GoodsOptionsSuppliesDeleteManyArgs} args - Arguments to filter GoodsOptionsSupplies to delete.
     * @example
     * // Delete a few GoodsOptionsSupplies
     * const { count } = await prisma.goodsOptionsSupplies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GoodsOptionsSuppliesDeleteManyArgs>(
      args?: SelectSubset<T, GoodsOptionsSuppliesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoodsOptionsSupplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsOptionsSuppliesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoodsOptionsSupplies
     * const goodsOptionsSupplies = await prisma.goodsOptionsSupplies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GoodsOptionsSuppliesUpdateManyArgs>(
      args: SelectSubset<T, GoodsOptionsSuppliesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one GoodsOptionsSupplies.
     * @param {GoodsOptionsSuppliesUpsertArgs} args - Arguments to update or create a GoodsOptionsSupplies.
     * @example
     * // Update or create a GoodsOptionsSupplies
     * const goodsOptionsSupplies = await prisma.goodsOptionsSupplies.upsert({
     *   create: {
     *     // ... data to create a GoodsOptionsSupplies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoodsOptionsSupplies we want to update
     *   }
     * })
    **/
    upsert<T extends GoodsOptionsSuppliesUpsertArgs>(
      args: SelectSubset<T, GoodsOptionsSuppliesUpsertArgs>
    ): CheckSelect<T, Prisma__GoodsOptionsSuppliesClient<GoodsOptionsSupplies>, Prisma__GoodsOptionsSuppliesClient<GoodsOptionsSuppliesGetPayload<T>>>

    /**
     * Count the number of GoodsOptionsSupplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsOptionsSuppliesCountArgs} args - Arguments to filter GoodsOptionsSupplies to count.
     * @example
     * // Count the number of GoodsOptionsSupplies
     * const count = await prisma.goodsOptionsSupplies.count({
     *   where: {
     *     // ... the filter for the GoodsOptionsSupplies we want to count
     *   }
     * })
    **/
    count<T extends GoodsOptionsSuppliesCountArgs>(
      args?: Subset<T, GoodsOptionsSuppliesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoodsOptionsSuppliesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoodsOptionsSupplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsOptionsSuppliesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoodsOptionsSuppliesAggregateArgs>(args: Subset<T, GoodsOptionsSuppliesAggregateArgs>): PrismaPromise<GetGoodsOptionsSuppliesAggregateType<T>>

    /**
     * Group by GoodsOptionsSupplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoodsOptionsSuppliesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoodsOptionsSuppliesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoodsOptionsSuppliesGroupByArgs['orderBy'] }
        : { orderBy?: GoodsOptionsSuppliesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoodsOptionsSuppliesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoodsOptionsSuppliesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for GoodsOptionsSupplies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GoodsOptionsSuppliesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    goodsOptions<T extends GoodsOptionsArgs = {}>(args?: Subset<T, GoodsOptionsArgs>): CheckSelect<T, Prisma__GoodsOptionsClient<GoodsOptions | null >, Prisma__GoodsOptionsClient<GoodsOptionsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * GoodsOptionsSupplies findUnique
   */
  export type GoodsOptionsSuppliesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the GoodsOptionsSupplies
     * 
    **/
    select?: GoodsOptionsSuppliesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsOptionsSuppliesInclude | null
    /**
     * Throw an Error if a GoodsOptionsSupplies can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GoodsOptionsSupplies to fetch.
     * 
    **/
    where: GoodsOptionsSuppliesWhereUniqueInput
  }


  /**
   * GoodsOptionsSupplies findFirst
   */
  export type GoodsOptionsSuppliesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the GoodsOptionsSupplies
     * 
    **/
    select?: GoodsOptionsSuppliesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsOptionsSuppliesInclude | null
    /**
     * Throw an Error if a GoodsOptionsSupplies can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GoodsOptionsSupplies to fetch.
     * 
    **/
    where?: GoodsOptionsSuppliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoodsOptionsSupplies to fetch.
     * 
    **/
    orderBy?: Enumerable<GoodsOptionsSuppliesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoodsOptionsSupplies.
     * 
    **/
    cursor?: GoodsOptionsSuppliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoodsOptionsSupplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoodsOptionsSupplies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoodsOptionsSupplies.
     * 
    **/
    distinct?: Enumerable<GoodsOptionsSuppliesScalarFieldEnum>
  }


  /**
   * GoodsOptionsSupplies findMany
   */
  export type GoodsOptionsSuppliesFindManyArgs = {
    /**
     * Select specific fields to fetch from the GoodsOptionsSupplies
     * 
    **/
    select?: GoodsOptionsSuppliesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsOptionsSuppliesInclude | null
    /**
     * Filter, which GoodsOptionsSupplies to fetch.
     * 
    **/
    where?: GoodsOptionsSuppliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoodsOptionsSupplies to fetch.
     * 
    **/
    orderBy?: Enumerable<GoodsOptionsSuppliesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoodsOptionsSupplies.
     * 
    **/
    cursor?: GoodsOptionsSuppliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoodsOptionsSupplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoodsOptionsSupplies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GoodsOptionsSuppliesScalarFieldEnum>
  }


  /**
   * GoodsOptionsSupplies create
   */
  export type GoodsOptionsSuppliesCreateArgs = {
    /**
     * Select specific fields to fetch from the GoodsOptionsSupplies
     * 
    **/
    select?: GoodsOptionsSuppliesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsOptionsSuppliesInclude | null
    /**
     * The data needed to create a GoodsOptionsSupplies.
     * 
    **/
    data: XOR<GoodsOptionsSuppliesCreateInput, GoodsOptionsSuppliesUncheckedCreateInput>
  }


  /**
   * GoodsOptionsSupplies createMany
   */
  export type GoodsOptionsSuppliesCreateManyArgs = {
    data: Enumerable<GoodsOptionsSuppliesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GoodsOptionsSupplies update
   */
  export type GoodsOptionsSuppliesUpdateArgs = {
    /**
     * Select specific fields to fetch from the GoodsOptionsSupplies
     * 
    **/
    select?: GoodsOptionsSuppliesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsOptionsSuppliesInclude | null
    /**
     * The data needed to update a GoodsOptionsSupplies.
     * 
    **/
    data: XOR<GoodsOptionsSuppliesUpdateInput, GoodsOptionsSuppliesUncheckedUpdateInput>
    /**
     * Choose, which GoodsOptionsSupplies to update.
     * 
    **/
    where: GoodsOptionsSuppliesWhereUniqueInput
  }


  /**
   * GoodsOptionsSupplies updateMany
   */
  export type GoodsOptionsSuppliesUpdateManyArgs = {
    data: XOR<GoodsOptionsSuppliesUpdateManyMutationInput, GoodsOptionsSuppliesUncheckedUpdateManyInput>
    where?: GoodsOptionsSuppliesWhereInput
  }


  /**
   * GoodsOptionsSupplies upsert
   */
  export type GoodsOptionsSuppliesUpsertArgs = {
    /**
     * Select specific fields to fetch from the GoodsOptionsSupplies
     * 
    **/
    select?: GoodsOptionsSuppliesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsOptionsSuppliesInclude | null
    /**
     * The filter to search for the GoodsOptionsSupplies to update in case it exists.
     * 
    **/
    where: GoodsOptionsSuppliesWhereUniqueInput
    /**
     * In case the GoodsOptionsSupplies found by the `where` argument doesn't exist, create a new GoodsOptionsSupplies with this data.
     * 
    **/
    create: XOR<GoodsOptionsSuppliesCreateInput, GoodsOptionsSuppliesUncheckedCreateInput>
    /**
     * In case the GoodsOptionsSupplies was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GoodsOptionsSuppliesUpdateInput, GoodsOptionsSuppliesUncheckedUpdateInput>
  }


  /**
   * GoodsOptionsSupplies delete
   */
  export type GoodsOptionsSuppliesDeleteArgs = {
    /**
     * Select specific fields to fetch from the GoodsOptionsSupplies
     * 
    **/
    select?: GoodsOptionsSuppliesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsOptionsSuppliesInclude | null
    /**
     * Filter which GoodsOptionsSupplies to delete.
     * 
    **/
    where: GoodsOptionsSuppliesWhereUniqueInput
  }


  /**
   * GoodsOptionsSupplies deleteMany
   */
  export type GoodsOptionsSuppliesDeleteManyArgs = {
    where?: GoodsOptionsSuppliesWhereInput
  }


  /**
   * GoodsOptionsSupplies without action
   */
  export type GoodsOptionsSuppliesArgs = {
    /**
     * Select specific fields to fetch from the GoodsOptionsSupplies
     * 
    **/
    select?: GoodsOptionsSuppliesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GoodsOptionsSuppliesInclude | null
  }



  /**
   * Model LiveCommerceRanking
   */


  export type AggregateLiveCommerceRanking = {
    _count: LiveCommerceRankingCountAggregateOutputType | null
    count: LiveCommerceRankingCountAggregateOutputType | null
    _avg: LiveCommerceRankingAvgAggregateOutputType | null
    avg: LiveCommerceRankingAvgAggregateOutputType | null
    _sum: LiveCommerceRankingSumAggregateOutputType | null
    sum: LiveCommerceRankingSumAggregateOutputType | null
    _min: LiveCommerceRankingMinAggregateOutputType | null
    min: LiveCommerceRankingMinAggregateOutputType | null
    _max: LiveCommerceRankingMaxAggregateOutputType | null
    max: LiveCommerceRankingMaxAggregateOutputType | null
  }

  export type LiveCommerceRankingAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type LiveCommerceRankingSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type LiveCommerceRankingMinAggregateOutputType = {
    id: number | null
    nickname: string | null
    text: string | null
    price: number | null
    phoneCallEventFlag: string | null
    loginFlag: string | null
    createdAt: Date | null
  }

  export type LiveCommerceRankingMaxAggregateOutputType = {
    id: number | null
    nickname: string | null
    text: string | null
    price: number | null
    phoneCallEventFlag: string | null
    loginFlag: string | null
    createdAt: Date | null
  }

  export type LiveCommerceRankingCountAggregateOutputType = {
    id: number
    nickname: number
    text: number
    price: number
    phoneCallEventFlag: number
    loginFlag: number
    createdAt: number
    _all: number
  }


  export type LiveCommerceRankingAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type LiveCommerceRankingSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type LiveCommerceRankingMinAggregateInputType = {
    id?: true
    nickname?: true
    text?: true
    price?: true
    phoneCallEventFlag?: true
    loginFlag?: true
    createdAt?: true
  }

  export type LiveCommerceRankingMaxAggregateInputType = {
    id?: true
    nickname?: true
    text?: true
    price?: true
    phoneCallEventFlag?: true
    loginFlag?: true
    createdAt?: true
  }

  export type LiveCommerceRankingCountAggregateInputType = {
    id?: true
    nickname?: true
    text?: true
    price?: true
    phoneCallEventFlag?: true
    loginFlag?: true
    createdAt?: true
    _all?: true
  }

  export type LiveCommerceRankingAggregateArgs = {
    /**
     * Filter which LiveCommerceRanking to aggregate.
     * 
    **/
    where?: LiveCommerceRankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveCommerceRankings to fetch.
     * 
    **/
    orderBy?: Enumerable<LiveCommerceRankingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LiveCommerceRankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveCommerceRankings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveCommerceRankings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiveCommerceRankings
    **/
    _count?: true | LiveCommerceRankingCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | LiveCommerceRankingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LiveCommerceRankingAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: LiveCommerceRankingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LiveCommerceRankingSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: LiveCommerceRankingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiveCommerceRankingMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: LiveCommerceRankingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiveCommerceRankingMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: LiveCommerceRankingMaxAggregateInputType
  }

  export type GetLiveCommerceRankingAggregateType<T extends LiveCommerceRankingAggregateArgs> = {
        [P in keyof T & keyof AggregateLiveCommerceRanking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiveCommerceRanking[P]>
      : GetScalarType<T[P], AggregateLiveCommerceRanking[P]>
  }


    
    
  export type LiveCommerceRankingGroupByArgs = {
    where?: LiveCommerceRankingWhereInput
    orderBy?: Enumerable<LiveCommerceRankingOrderByInput>
    by: Array<LiveCommerceRankingScalarFieldEnum>
    having?: LiveCommerceRankingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiveCommerceRankingCountAggregateInputType | true
    _avg?: LiveCommerceRankingAvgAggregateInputType
    _sum?: LiveCommerceRankingSumAggregateInputType
    _min?: LiveCommerceRankingMinAggregateInputType
    _max?: LiveCommerceRankingMaxAggregateInputType
  }


  export type LiveCommerceRankingGroupByOutputType = {
    id: number
    nickname: string
    text: string
    price: number
    phoneCallEventFlag: string
    loginFlag: string
    createdAt: Date
    _count: LiveCommerceRankingCountAggregateOutputType | null
    _avg: LiveCommerceRankingAvgAggregateOutputType | null
    _sum: LiveCommerceRankingSumAggregateOutputType | null
    _min: LiveCommerceRankingMinAggregateOutputType | null
    _max: LiveCommerceRankingMaxAggregateOutputType | null
  }

  type GetLiveCommerceRankingGroupByPayload<T extends LiveCommerceRankingGroupByArgs> = Promise<
    Array<
      PickArray<LiveCommerceRankingGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof LiveCommerceRankingGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], LiveCommerceRankingGroupByOutputType[P]> 
            : GetScalarType<T[P], LiveCommerceRankingGroupByOutputType[P]>
        }
      > 
    >


  export type LiveCommerceRankingSelect = {
    id?: boolean
    nickname?: boolean
    text?: boolean
    price?: boolean
    phoneCallEventFlag?: boolean
    loginFlag?: boolean
    createdAt?: boolean
  }

  export type LiveCommerceRankingGetPayload<
    S extends boolean | null | undefined | LiveCommerceRankingArgs,
    U = keyof S
      > = S extends true
        ? LiveCommerceRanking
    : S extends undefined
    ? never
    : S extends LiveCommerceRankingArgs | LiveCommerceRankingFindManyArgs
    ?'include' extends U
    ? LiveCommerceRanking 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof LiveCommerceRanking ?LiveCommerceRanking [P]
  : 
     never
  } 
    : LiveCommerceRanking
  : LiveCommerceRanking


  type LiveCommerceRankingCountArgs = Merge<
    Omit<LiveCommerceRankingFindManyArgs, 'select' | 'include'> & {
      select?: LiveCommerceRankingCountAggregateInputType | true
    }
  >

  export interface LiveCommerceRankingDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one LiveCommerceRanking that matches the filter.
     * @param {LiveCommerceRankingFindUniqueArgs} args - Arguments to find a LiveCommerceRanking
     * @example
     * // Get one LiveCommerceRanking
     * const liveCommerceRanking = await prisma.liveCommerceRanking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LiveCommerceRankingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LiveCommerceRankingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LiveCommerceRanking'> extends True ? CheckSelect<T, Prisma__LiveCommerceRankingClient<LiveCommerceRanking>, Prisma__LiveCommerceRankingClient<LiveCommerceRankingGetPayload<T>>> : CheckSelect<T, Prisma__LiveCommerceRankingClient<LiveCommerceRanking | null >, Prisma__LiveCommerceRankingClient<LiveCommerceRankingGetPayload<T> | null >>

    /**
     * Find the first LiveCommerceRanking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveCommerceRankingFindFirstArgs} args - Arguments to find a LiveCommerceRanking
     * @example
     * // Get one LiveCommerceRanking
     * const liveCommerceRanking = await prisma.liveCommerceRanking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LiveCommerceRankingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LiveCommerceRankingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LiveCommerceRanking'> extends True ? CheckSelect<T, Prisma__LiveCommerceRankingClient<LiveCommerceRanking>, Prisma__LiveCommerceRankingClient<LiveCommerceRankingGetPayload<T>>> : CheckSelect<T, Prisma__LiveCommerceRankingClient<LiveCommerceRanking | null >, Prisma__LiveCommerceRankingClient<LiveCommerceRankingGetPayload<T> | null >>

    /**
     * Find zero or more LiveCommerceRankings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveCommerceRankingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiveCommerceRankings
     * const liveCommerceRankings = await prisma.liveCommerceRanking.findMany()
     * 
     * // Get first 10 LiveCommerceRankings
     * const liveCommerceRankings = await prisma.liveCommerceRanking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liveCommerceRankingWithIdOnly = await prisma.liveCommerceRanking.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LiveCommerceRankingFindManyArgs>(
      args?: SelectSubset<T, LiveCommerceRankingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<LiveCommerceRanking>>, PrismaPromise<Array<LiveCommerceRankingGetPayload<T>>>>

    /**
     * Create a LiveCommerceRanking.
     * @param {LiveCommerceRankingCreateArgs} args - Arguments to create a LiveCommerceRanking.
     * @example
     * // Create one LiveCommerceRanking
     * const LiveCommerceRanking = await prisma.liveCommerceRanking.create({
     *   data: {
     *     // ... data to create a LiveCommerceRanking
     *   }
     * })
     * 
    **/
    create<T extends LiveCommerceRankingCreateArgs>(
      args: SelectSubset<T, LiveCommerceRankingCreateArgs>
    ): CheckSelect<T, Prisma__LiveCommerceRankingClient<LiveCommerceRanking>, Prisma__LiveCommerceRankingClient<LiveCommerceRankingGetPayload<T>>>

    /**
     * Create many LiveCommerceRankings.
     *     @param {LiveCommerceRankingCreateManyArgs} args - Arguments to create many LiveCommerceRankings.
     *     @example
     *     // Create many LiveCommerceRankings
     *     const liveCommerceRanking = await prisma.liveCommerceRanking.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LiveCommerceRankingCreateManyArgs>(
      args?: SelectSubset<T, LiveCommerceRankingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a LiveCommerceRanking.
     * @param {LiveCommerceRankingDeleteArgs} args - Arguments to delete one LiveCommerceRanking.
     * @example
     * // Delete one LiveCommerceRanking
     * const LiveCommerceRanking = await prisma.liveCommerceRanking.delete({
     *   where: {
     *     // ... filter to delete one LiveCommerceRanking
     *   }
     * })
     * 
    **/
    delete<T extends LiveCommerceRankingDeleteArgs>(
      args: SelectSubset<T, LiveCommerceRankingDeleteArgs>
    ): CheckSelect<T, Prisma__LiveCommerceRankingClient<LiveCommerceRanking>, Prisma__LiveCommerceRankingClient<LiveCommerceRankingGetPayload<T>>>

    /**
     * Update one LiveCommerceRanking.
     * @param {LiveCommerceRankingUpdateArgs} args - Arguments to update one LiveCommerceRanking.
     * @example
     * // Update one LiveCommerceRanking
     * const liveCommerceRanking = await prisma.liveCommerceRanking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LiveCommerceRankingUpdateArgs>(
      args: SelectSubset<T, LiveCommerceRankingUpdateArgs>
    ): CheckSelect<T, Prisma__LiveCommerceRankingClient<LiveCommerceRanking>, Prisma__LiveCommerceRankingClient<LiveCommerceRankingGetPayload<T>>>

    /**
     * Delete zero or more LiveCommerceRankings.
     * @param {LiveCommerceRankingDeleteManyArgs} args - Arguments to filter LiveCommerceRankings to delete.
     * @example
     * // Delete a few LiveCommerceRankings
     * const { count } = await prisma.liveCommerceRanking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LiveCommerceRankingDeleteManyArgs>(
      args?: SelectSubset<T, LiveCommerceRankingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiveCommerceRankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveCommerceRankingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiveCommerceRankings
     * const liveCommerceRanking = await prisma.liveCommerceRanking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LiveCommerceRankingUpdateManyArgs>(
      args: SelectSubset<T, LiveCommerceRankingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one LiveCommerceRanking.
     * @param {LiveCommerceRankingUpsertArgs} args - Arguments to update or create a LiveCommerceRanking.
     * @example
     * // Update or create a LiveCommerceRanking
     * const liveCommerceRanking = await prisma.liveCommerceRanking.upsert({
     *   create: {
     *     // ... data to create a LiveCommerceRanking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiveCommerceRanking we want to update
     *   }
     * })
    **/
    upsert<T extends LiveCommerceRankingUpsertArgs>(
      args: SelectSubset<T, LiveCommerceRankingUpsertArgs>
    ): CheckSelect<T, Prisma__LiveCommerceRankingClient<LiveCommerceRanking>, Prisma__LiveCommerceRankingClient<LiveCommerceRankingGetPayload<T>>>

    /**
     * Count the number of LiveCommerceRankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveCommerceRankingCountArgs} args - Arguments to filter LiveCommerceRankings to count.
     * @example
     * // Count the number of LiveCommerceRankings
     * const count = await prisma.liveCommerceRanking.count({
     *   where: {
     *     // ... the filter for the LiveCommerceRankings we want to count
     *   }
     * })
    **/
    count<T extends LiveCommerceRankingCountArgs>(
      args?: Subset<T, LiveCommerceRankingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiveCommerceRankingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiveCommerceRanking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveCommerceRankingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiveCommerceRankingAggregateArgs>(args: Subset<T, LiveCommerceRankingAggregateArgs>): PrismaPromise<GetLiveCommerceRankingAggregateType<T>>

    /**
     * Group by LiveCommerceRanking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveCommerceRankingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiveCommerceRankingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiveCommerceRankingGroupByArgs['orderBy'] }
        : { orderBy?: LiveCommerceRankingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiveCommerceRankingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiveCommerceRankingGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for LiveCommerceRanking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LiveCommerceRankingClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * LiveCommerceRanking findUnique
   */
  export type LiveCommerceRankingFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the LiveCommerceRanking
     * 
    **/
    select?: LiveCommerceRankingSelect | null
    /**
     * Throw an Error if a LiveCommerceRanking can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LiveCommerceRanking to fetch.
     * 
    **/
    where: LiveCommerceRankingWhereUniqueInput
  }


  /**
   * LiveCommerceRanking findFirst
   */
  export type LiveCommerceRankingFindFirstArgs = {
    /**
     * Select specific fields to fetch from the LiveCommerceRanking
     * 
    **/
    select?: LiveCommerceRankingSelect | null
    /**
     * Throw an Error if a LiveCommerceRanking can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LiveCommerceRanking to fetch.
     * 
    **/
    where?: LiveCommerceRankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveCommerceRankings to fetch.
     * 
    **/
    orderBy?: Enumerable<LiveCommerceRankingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiveCommerceRankings.
     * 
    **/
    cursor?: LiveCommerceRankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveCommerceRankings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveCommerceRankings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiveCommerceRankings.
     * 
    **/
    distinct?: Enumerable<LiveCommerceRankingScalarFieldEnum>
  }


  /**
   * LiveCommerceRanking findMany
   */
  export type LiveCommerceRankingFindManyArgs = {
    /**
     * Select specific fields to fetch from the LiveCommerceRanking
     * 
    **/
    select?: LiveCommerceRankingSelect | null
    /**
     * Filter, which LiveCommerceRankings to fetch.
     * 
    **/
    where?: LiveCommerceRankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveCommerceRankings to fetch.
     * 
    **/
    orderBy?: Enumerable<LiveCommerceRankingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiveCommerceRankings.
     * 
    **/
    cursor?: LiveCommerceRankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveCommerceRankings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveCommerceRankings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LiveCommerceRankingScalarFieldEnum>
  }


  /**
   * LiveCommerceRanking create
   */
  export type LiveCommerceRankingCreateArgs = {
    /**
     * Select specific fields to fetch from the LiveCommerceRanking
     * 
    **/
    select?: LiveCommerceRankingSelect | null
    /**
     * The data needed to create a LiveCommerceRanking.
     * 
    **/
    data: XOR<LiveCommerceRankingCreateInput, LiveCommerceRankingUncheckedCreateInput>
  }


  /**
   * LiveCommerceRanking createMany
   */
  export type LiveCommerceRankingCreateManyArgs = {
    data: Enumerable<LiveCommerceRankingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LiveCommerceRanking update
   */
  export type LiveCommerceRankingUpdateArgs = {
    /**
     * Select specific fields to fetch from the LiveCommerceRanking
     * 
    **/
    select?: LiveCommerceRankingSelect | null
    /**
     * The data needed to update a LiveCommerceRanking.
     * 
    **/
    data: XOR<LiveCommerceRankingUpdateInput, LiveCommerceRankingUncheckedUpdateInput>
    /**
     * Choose, which LiveCommerceRanking to update.
     * 
    **/
    where: LiveCommerceRankingWhereUniqueInput
  }


  /**
   * LiveCommerceRanking updateMany
   */
  export type LiveCommerceRankingUpdateManyArgs = {
    data: XOR<LiveCommerceRankingUpdateManyMutationInput, LiveCommerceRankingUncheckedUpdateManyInput>
    where?: LiveCommerceRankingWhereInput
  }


  /**
   * LiveCommerceRanking upsert
   */
  export type LiveCommerceRankingUpsertArgs = {
    /**
     * Select specific fields to fetch from the LiveCommerceRanking
     * 
    **/
    select?: LiveCommerceRankingSelect | null
    /**
     * The filter to search for the LiveCommerceRanking to update in case it exists.
     * 
    **/
    where: LiveCommerceRankingWhereUniqueInput
    /**
     * In case the LiveCommerceRanking found by the `where` argument doesn't exist, create a new LiveCommerceRanking with this data.
     * 
    **/
    create: XOR<LiveCommerceRankingCreateInput, LiveCommerceRankingUncheckedCreateInput>
    /**
     * In case the LiveCommerceRanking was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LiveCommerceRankingUpdateInput, LiveCommerceRankingUncheckedUpdateInput>
  }


  /**
   * LiveCommerceRanking delete
   */
  export type LiveCommerceRankingDeleteArgs = {
    /**
     * Select specific fields to fetch from the LiveCommerceRanking
     * 
    **/
    select?: LiveCommerceRankingSelect | null
    /**
     * Filter which LiveCommerceRanking to delete.
     * 
    **/
    where: LiveCommerceRankingWhereUniqueInput
  }


  /**
   * LiveCommerceRanking deleteMany
   */
  export type LiveCommerceRankingDeleteManyArgs = {
    where?: LiveCommerceRankingWhereInput
  }


  /**
   * LiveCommerceRanking without action
   */
  export type LiveCommerceRankingArgs = {
    /**
     * Select specific fields to fetch from the LiveCommerceRanking
     * 
    **/
    select?: LiveCommerceRankingSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const SellerScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password'
  };

  export type SellerScalarFieldEnum = (typeof SellerScalarFieldEnum)[keyof typeof SellerScalarFieldEnum]


  export const MailVerificationCodeScalarFieldEnum: {
    id: 'id',
    email: 'email',
    verificationCode: 'verificationCode',
    createDate: 'createDate'
  };

  export type MailVerificationCodeScalarFieldEnum = (typeof MailVerificationCodeScalarFieldEnum)[keyof typeof MailVerificationCodeScalarFieldEnum]


  export const SellerSocialAccountScalarFieldEnum: {
    serviceId: 'serviceId',
    provider: 'provider',
    name: 'name',
    registDate: 'registDate',
    profileImage: 'profileImage',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    sellerId: 'sellerId'
  };

  export type SellerSocialAccountScalarFieldEnum = (typeof SellerSocialAccountScalarFieldEnum)[keyof typeof SellerSocialAccountScalarFieldEnum]


  export const GoodsScalarFieldEnum: {
    id: 'id',
    sellerId: 'sellerId',
    goods_name: 'goods_name',
    summary: 'summary',
    goods_status: 'goods_status',
    cancel_type: 'cancel_type',
    contents: 'contents',
    contents_mobile: 'contents_mobile',
    common_contents: 'common_contents',
    shipping_policy: 'shipping_policy',
    goods_shipping_policy: 'goods_shipping_policy',
    unlimit_shipping_price: 'unlimit_shipping_price',
    limit_shipping_ea: 'limit_shipping_ea',
    limit_shipping_price: 'limit_shipping_price',
    limit_shipping_subprice: 'limit_shipping_subprice',
    shipping_weight_policy: 'shipping_weight_policy',
    min_purchase_limit: 'min_purchase_limit',
    min_purchase_ea: 'min_purchase_ea',
    max_purchase_limit: 'max_purchase_limit',
    max_purchase_ea: 'max_purchase_ea',
    max_urchase_order_limit: 'max_urchase_order_limit',
    admin_memo: 'admin_memo',
    option_use: 'option_use',
    option_view_type: 'option_view_type',
    option_suboption_use: 'option_suboption_use',
    member_input_use: 'member_input_use',
    image: 'image'
  };

  export type GoodsScalarFieldEnum = (typeof GoodsScalarFieldEnum)[keyof typeof GoodsScalarFieldEnum]


  export const GoodsConfirmationScalarFieldEnum: {
    id: 'id',
    goodsId: 'goodsId',
    status: 'status',
    firstmallGoodsConnectionId: 'firstmallGoodsConnectionId'
  };

  export type GoodsConfirmationScalarFieldEnum = (typeof GoodsConfirmationScalarFieldEnum)[keyof typeof GoodsConfirmationScalarFieldEnum]


  export const GoodsOptionsScalarFieldEnum: {
    id: 'id',
    goodsId: 'goodsId',
    default_option: 'default_option',
    option_type: 'option_type',
    option_title: 'option_title',
    option_code: 'option_code',
    consumer_price: 'consumer_price',
    price: 'price',
    color: 'color',
    weight: 'weight',
    option_view: 'option_view'
  };

  export type GoodsOptionsScalarFieldEnum = (typeof GoodsOptionsScalarFieldEnum)[keyof typeof GoodsOptionsScalarFieldEnum]


  export const GoodsOptionsSuppliesScalarFieldEnum: {
    id: 'id',
    goodsOptionsId: 'goodsOptionsId',
    stock: 'stock',
    badstock: 'badstock',
    safe_stock: 'safe_stock'
  };

  export type GoodsOptionsSuppliesScalarFieldEnum = (typeof GoodsOptionsSuppliesScalarFieldEnum)[keyof typeof GoodsOptionsSuppliesScalarFieldEnum]


  export const LiveCommerceRankingScalarFieldEnum: {
    id: 'id',
    nickname: 'nickname',
    text: 'text',
    price: 'price',
    phoneCallEventFlag: 'phoneCallEventFlag',
    loginFlag: 'loginFlag',
    createdAt: 'createdAt'
  };

  export type LiveCommerceRankingScalarFieldEnum = (typeof LiveCommerceRankingScalarFieldEnum)[keyof typeof LiveCommerceRankingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type SellerWhereInput = {
    AND?: Enumerable<SellerWhereInput>
    OR?: Enumerable<SellerWhereInput>
    NOT?: Enumerable<SellerWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    name?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    socialAccounts?: SellerSocialAccountListRelationFilter
    goods?: GoodsListRelationFilter
  }

  export type SellerOrderByInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
  }

  export type SellerWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type SellerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SellerScalarWhereWithAggregatesInput>
    OR?: Enumerable<SellerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SellerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
  }

  export type MailVerificationCodeWhereInput = {
    AND?: Enumerable<MailVerificationCodeWhereInput>
    OR?: Enumerable<MailVerificationCodeWhereInput>
    NOT?: Enumerable<MailVerificationCodeWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    verificationCode?: StringFilter | string
    createDate?: DateTimeFilter | Date | string
  }

  export type MailVerificationCodeOrderByInput = {
    id?: SortOrder
    email?: SortOrder
    verificationCode?: SortOrder
    createDate?: SortOrder
  }

  export type MailVerificationCodeWhereUniqueInput = {
    id?: number
  }

  export type MailVerificationCodeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MailVerificationCodeScalarWhereWithAggregatesInput>
    OR?: Enumerable<MailVerificationCodeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MailVerificationCodeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    verificationCode?: StringWithAggregatesFilter | string
    createDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SellerSocialAccountWhereInput = {
    AND?: Enumerable<SellerSocialAccountWhereInput>
    OR?: Enumerable<SellerSocialAccountWhereInput>
    NOT?: Enumerable<SellerSocialAccountWhereInput>
    serviceId?: StringFilter | string
    provider?: StringFilter | string
    name?: StringFilter | string
    registDate?: DateTimeFilter | Date | string
    profileImage?: StringNullableFilter | string | null
    accessToken?: StringNullableFilter | string | null
    refreshToken?: StringNullableFilter | string | null
    seller?: XOR<SellerRelationFilter, SellerWhereInput>
    sellerId?: IntFilter | number
  }

  export type SellerSocialAccountOrderByInput = {
    serviceId?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    registDate?: SortOrder
    profileImage?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    sellerId?: SortOrder
  }

  export type SellerSocialAccountWhereUniqueInput = {
    serviceId?: string
  }

  export type SellerSocialAccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SellerSocialAccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<SellerSocialAccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SellerSocialAccountScalarWhereWithAggregatesInput>
    serviceId?: StringWithAggregatesFilter | string
    provider?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    registDate?: DateTimeWithAggregatesFilter | Date | string
    profileImage?: StringNullableWithAggregatesFilter | string | null
    accessToken?: StringNullableWithAggregatesFilter | string | null
    refreshToken?: StringNullableWithAggregatesFilter | string | null
    sellerId?: IntWithAggregatesFilter | number
  }

  export type GoodsWhereInput = {
    AND?: Enumerable<GoodsWhereInput>
    OR?: Enumerable<GoodsWhereInput>
    NOT?: Enumerable<GoodsWhereInput>
    id?: IntFilter | number
    sellerId?: IntFilter | number
    seller?: XOR<SellerRelationFilter, SellerWhereInput>
    options?: GoodsOptionsListRelationFilter
    confirmation?: XOR<GoodsConfirmationRelationFilter, GoodsConfirmationWhereInput> | null
    goods_name?: StringFilter | string
    summary?: StringFilter | string
    goods_status?: EnumGoodsStatusFilter | GoodsStatus
    cancel_type?: StringFilter | string
    contents?: StringNullableFilter | string | null
    contents_mobile?: StringNullableFilter | string | null
    common_contents?: StringFilter | string
    shipping_policy?: EnumShopOrGoodsFilter | ShopOrGoods
    goods_shipping_policy?: EnumLimitOrUnlimitFilter | LimitOrUnlimit
    unlimit_shipping_price?: IntNullableFilter | number | null
    limit_shipping_ea?: IntNullableFilter | number | null
    limit_shipping_price?: IntNullableFilter | number | null
    limit_shipping_subprice?: IntNullableFilter | number | null
    shipping_weight_policy?: EnumShopOrGoodsFilter | ShopOrGoods
    min_purchase_limit?: EnumLimitOrUnlimitFilter | LimitOrUnlimit
    min_purchase_ea?: IntNullableFilter | number | null
    max_purchase_limit?: EnumLimitOrUnlimitFilter | LimitOrUnlimit
    max_purchase_ea?: IntNullableFilter | number | null
    max_urchase_order_limit?: IntNullableFilter | number | null
    admin_memo?: StringNullableFilter | string | null
    option_use?: StringFilter | string
    option_view_type?: EnumOptionViewTypeFilter | OptionViewType
    option_suboption_use?: StringFilter | string
    member_input_use?: StringFilter | string
    image?: StringFilter | string
  }

  export type GoodsOrderByInput = {
    id?: SortOrder
    sellerId?: SortOrder
    goods_name?: SortOrder
    summary?: SortOrder
    goods_status?: SortOrder
    cancel_type?: SortOrder
    contents?: SortOrder
    contents_mobile?: SortOrder
    common_contents?: SortOrder
    shipping_policy?: SortOrder
    goods_shipping_policy?: SortOrder
    unlimit_shipping_price?: SortOrder
    limit_shipping_ea?: SortOrder
    limit_shipping_price?: SortOrder
    limit_shipping_subprice?: SortOrder
    shipping_weight_policy?: SortOrder
    min_purchase_limit?: SortOrder
    min_purchase_ea?: SortOrder
    max_purchase_limit?: SortOrder
    max_purchase_ea?: SortOrder
    max_urchase_order_limit?: SortOrder
    admin_memo?: SortOrder
    option_use?: SortOrder
    option_view_type?: SortOrder
    option_suboption_use?: SortOrder
    member_input_use?: SortOrder
    image?: SortOrder
  }

  export type GoodsWhereUniqueInput = {
    id?: number
  }

  export type GoodsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GoodsScalarWhereWithAggregatesInput>
    OR?: Enumerable<GoodsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GoodsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    sellerId?: IntWithAggregatesFilter | number
    goods_name?: StringWithAggregatesFilter | string
    summary?: StringWithAggregatesFilter | string
    goods_status?: EnumGoodsStatusWithAggregatesFilter | GoodsStatus
    cancel_type?: StringWithAggregatesFilter | string
    contents?: StringNullableWithAggregatesFilter | string | null
    contents_mobile?: StringNullableWithAggregatesFilter | string | null
    common_contents?: StringWithAggregatesFilter | string
    shipping_policy?: EnumShopOrGoodsWithAggregatesFilter | ShopOrGoods
    goods_shipping_policy?: EnumLimitOrUnlimitWithAggregatesFilter | LimitOrUnlimit
    unlimit_shipping_price?: IntNullableWithAggregatesFilter | number | null
    limit_shipping_ea?: IntNullableWithAggregatesFilter | number | null
    limit_shipping_price?: IntNullableWithAggregatesFilter | number | null
    limit_shipping_subprice?: IntNullableWithAggregatesFilter | number | null
    shipping_weight_policy?: EnumShopOrGoodsWithAggregatesFilter | ShopOrGoods
    min_purchase_limit?: EnumLimitOrUnlimitWithAggregatesFilter | LimitOrUnlimit
    min_purchase_ea?: IntNullableWithAggregatesFilter | number | null
    max_purchase_limit?: EnumLimitOrUnlimitWithAggregatesFilter | LimitOrUnlimit
    max_purchase_ea?: IntNullableWithAggregatesFilter | number | null
    max_urchase_order_limit?: IntNullableWithAggregatesFilter | number | null
    admin_memo?: StringNullableWithAggregatesFilter | string | null
    option_use?: StringWithAggregatesFilter | string
    option_view_type?: EnumOptionViewTypeWithAggregatesFilter | OptionViewType
    option_suboption_use?: StringWithAggregatesFilter | string
    member_input_use?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
  }

  export type GoodsConfirmationWhereInput = {
    AND?: Enumerable<GoodsConfirmationWhereInput>
    OR?: Enumerable<GoodsConfirmationWhereInput>
    NOT?: Enumerable<GoodsConfirmationWhereInput>
    id?: IntFilter | number
    goodsId?: IntFilter | number
    goods?: XOR<GoodsRelationFilter, GoodsWhereInput>
    status?: EnumGoodsConfirmationStatusesFilter | GoodsConfirmationStatuses
    firstmallGoodsConnectionId?: IntNullableFilter | number | null
  }

  export type GoodsConfirmationOrderByInput = {
    id?: SortOrder
    goodsId?: SortOrder
    status?: SortOrder
    firstmallGoodsConnectionId?: SortOrder
  }

  export type GoodsConfirmationWhereUniqueInput = {
    id?: number
  }

  export type GoodsConfirmationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GoodsConfirmationScalarWhereWithAggregatesInput>
    OR?: Enumerable<GoodsConfirmationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GoodsConfirmationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    goodsId?: IntWithAggregatesFilter | number
    status?: EnumGoodsConfirmationStatusesWithAggregatesFilter | GoodsConfirmationStatuses
    firstmallGoodsConnectionId?: IntNullableWithAggregatesFilter | number | null
  }

  export type GoodsOptionsWhereInput = {
    AND?: Enumerable<GoodsOptionsWhereInput>
    OR?: Enumerable<GoodsOptionsWhereInput>
    NOT?: Enumerable<GoodsOptionsWhereInput>
    id?: IntFilter | number
    goods?: XOR<GoodsRelationFilter, GoodsWhereInput>
    goodsId?: IntFilter | number
    supply?: GoodsOptionsSuppliesListRelationFilter
    default_option?: EnumYesOrNoFilter | YesOrNo
    option_type?: StringFilter | string
    option_title?: StringNullableFilter | string | null
    option_code?: StringNullableFilter | string | null
    consumer_price?: DecimalFilter | Decimal | number | string
    price?: DecimalFilter | Decimal | number | string
    color?: StringNullableFilter | string | null
    weight?: FloatNullableFilter | number | null
    option_view?: EnumYesOrNo_UPPERCASEFilter | YesOrNo_UPPERCASE
  }

  export type GoodsOptionsOrderByInput = {
    id?: SortOrder
    goodsId?: SortOrder
    default_option?: SortOrder
    option_type?: SortOrder
    option_title?: SortOrder
    option_code?: SortOrder
    consumer_price?: SortOrder
    price?: SortOrder
    color?: SortOrder
    weight?: SortOrder
    option_view?: SortOrder
  }

  export type GoodsOptionsWhereUniqueInput = {
    id?: number
  }

  export type GoodsOptionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GoodsOptionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<GoodsOptionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GoodsOptionsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    goodsId?: IntWithAggregatesFilter | number
    default_option?: EnumYesOrNoWithAggregatesFilter | YesOrNo
    option_type?: StringWithAggregatesFilter | string
    option_title?: StringNullableWithAggregatesFilter | string | null
    option_code?: StringNullableWithAggregatesFilter | string | null
    consumer_price?: DecimalWithAggregatesFilter | Decimal | number | string
    price?: DecimalWithAggregatesFilter | Decimal | number | string
    color?: StringNullableWithAggregatesFilter | string | null
    weight?: FloatNullableWithAggregatesFilter | number | null
    option_view?: EnumYesOrNo_UPPERCASEWithAggregatesFilter | YesOrNo_UPPERCASE
  }

  export type GoodsOptionsSuppliesWhereInput = {
    AND?: Enumerable<GoodsOptionsSuppliesWhereInput>
    OR?: Enumerable<GoodsOptionsSuppliesWhereInput>
    NOT?: Enumerable<GoodsOptionsSuppliesWhereInput>
    id?: IntFilter | number
    goodsOptions?: XOR<GoodsOptionsRelationFilter, GoodsOptionsWhereInput>
    goodsOptionsId?: IntFilter | number
    stock?: IntFilter | number
    badstock?: IntNullableFilter | number | null
    safe_stock?: IntNullableFilter | number | null
  }

  export type GoodsOptionsSuppliesOrderByInput = {
    id?: SortOrder
    goodsOptionsId?: SortOrder
    stock?: SortOrder
    badstock?: SortOrder
    safe_stock?: SortOrder
  }

  export type GoodsOptionsSuppliesWhereUniqueInput = {
    id?: number
  }

  export type GoodsOptionsSuppliesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GoodsOptionsSuppliesScalarWhereWithAggregatesInput>
    OR?: Enumerable<GoodsOptionsSuppliesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GoodsOptionsSuppliesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    goodsOptionsId?: IntWithAggregatesFilter | number
    stock?: IntWithAggregatesFilter | number
    badstock?: IntNullableWithAggregatesFilter | number | null
    safe_stock?: IntNullableWithAggregatesFilter | number | null
  }

  export type LiveCommerceRankingWhereInput = {
    AND?: Enumerable<LiveCommerceRankingWhereInput>
    OR?: Enumerable<LiveCommerceRankingWhereInput>
    NOT?: Enumerable<LiveCommerceRankingWhereInput>
    id?: IntFilter | number
    nickname?: StringFilter | string
    text?: StringFilter | string
    price?: IntFilter | number
    phoneCallEventFlag?: StringFilter | string
    loginFlag?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type LiveCommerceRankingOrderByInput = {
    id?: SortOrder
    nickname?: SortOrder
    text?: SortOrder
    price?: SortOrder
    phoneCallEventFlag?: SortOrder
    loginFlag?: SortOrder
    createdAt?: SortOrder
  }

  export type LiveCommerceRankingWhereUniqueInput = {
    id?: number
  }

  export type LiveCommerceRankingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LiveCommerceRankingScalarWhereWithAggregatesInput>
    OR?: Enumerable<LiveCommerceRankingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LiveCommerceRankingScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nickname?: StringWithAggregatesFilter | string
    text?: StringWithAggregatesFilter | string
    price?: IntWithAggregatesFilter | number
    phoneCallEventFlag?: StringWithAggregatesFilter | string
    loginFlag?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SellerCreateInput = {
    email: string
    name?: string | null
    password?: string | null
    socialAccounts?: SellerSocialAccountCreateNestedManyWithoutSellerInput
    goods?: GoodsCreateNestedManyWithoutSellerInput
  }

  export type SellerUncheckedCreateInput = {
    id?: number
    email: string
    name?: string | null
    password?: string | null
    socialAccounts?: SellerSocialAccountUncheckedCreateNestedManyWithoutSellerInput
    goods?: GoodsUncheckedCreateNestedManyWithoutSellerInput
  }

  export type SellerUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    socialAccounts?: SellerSocialAccountUpdateManyWithoutSellerInput
    goods?: GoodsUpdateManyWithoutSellerInput
  }

  export type SellerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    socialAccounts?: SellerSocialAccountUncheckedUpdateManyWithoutSellerInput
    goods?: GoodsUncheckedUpdateManyWithoutSellerInput
  }

  export type SellerCreateManyInput = {
    id?: number
    email: string
    name?: string | null
    password?: string | null
  }

  export type SellerUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SellerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MailVerificationCodeCreateInput = {
    email?: string
    verificationCode: string
    createDate?: Date | string
  }

  export type MailVerificationCodeUncheckedCreateInput = {
    id?: number
    email?: string
    verificationCode: string
    createDate?: Date | string
  }

  export type MailVerificationCodeUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    verificationCode?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailVerificationCodeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    verificationCode?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailVerificationCodeCreateManyInput = {
    id?: number
    email?: string
    verificationCode: string
    createDate?: Date | string
  }

  export type MailVerificationCodeUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    verificationCode?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailVerificationCodeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    verificationCode?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerSocialAccountCreateInput = {
    serviceId: string
    provider: string
    name: string
    registDate?: Date | string
    profileImage?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    seller: SellerCreateNestedOneWithoutSocialAccountsInput
  }

  export type SellerSocialAccountUncheckedCreateInput = {
    serviceId: string
    provider: string
    name: string
    registDate?: Date | string
    profileImage?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    sellerId: number
  }

  export type SellerSocialAccountUpdateInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    registDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    seller?: SellerUpdateOneRequiredWithoutSocialAccountsInput
  }

  export type SellerSocialAccountUncheckedUpdateInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    registDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: IntFieldUpdateOperationsInput | number
  }

  export type SellerSocialAccountCreateManyInput = {
    serviceId: string
    provider: string
    name: string
    registDate?: Date | string
    profileImage?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    sellerId: number
  }

  export type SellerSocialAccountUpdateManyMutationInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    registDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SellerSocialAccountUncheckedUpdateManyInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    registDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: IntFieldUpdateOperationsInput | number
  }

  export type GoodsCreateInput = {
    goods_name: string
    summary: string
    goods_status?: GoodsStatus
    cancel_type?: string
    contents?: string | null
    contents_mobile?: string | null
    common_contents: string
    shipping_policy?: ShopOrGoods
    goods_shipping_policy?: LimitOrUnlimit
    unlimit_shipping_price?: number | null
    limit_shipping_ea?: number | null
    limit_shipping_price?: number | null
    limit_shipping_subprice?: number | null
    shipping_weight_policy?: ShopOrGoods
    min_purchase_limit?: LimitOrUnlimit
    min_purchase_ea?: number | null
    max_purchase_limit?: LimitOrUnlimit
    max_purchase_ea?: number | null
    max_urchase_order_limit?: number | null
    admin_memo?: string | null
    option_use?: string
    option_view_type?: OptionViewType
    option_suboption_use?: string
    member_input_use?: string
    image: string
    seller: SellerCreateNestedOneWithoutGoodsInput
    options?: GoodsOptionsCreateNestedManyWithoutGoodsInput
    confirmation?: GoodsConfirmationCreateNestedOneWithoutGoodsInput
  }

  export type GoodsUncheckedCreateInput = {
    id?: number
    sellerId: number
    goods_name: string
    summary: string
    goods_status?: GoodsStatus
    cancel_type?: string
    contents?: string | null
    contents_mobile?: string | null
    common_contents: string
    shipping_policy?: ShopOrGoods
    goods_shipping_policy?: LimitOrUnlimit
    unlimit_shipping_price?: number | null
    limit_shipping_ea?: number | null
    limit_shipping_price?: number | null
    limit_shipping_subprice?: number | null
    shipping_weight_policy?: ShopOrGoods
    min_purchase_limit?: LimitOrUnlimit
    min_purchase_ea?: number | null
    max_purchase_limit?: LimitOrUnlimit
    max_purchase_ea?: number | null
    max_urchase_order_limit?: number | null
    admin_memo?: string | null
    option_use?: string
    option_view_type?: OptionViewType
    option_suboption_use?: string
    member_input_use?: string
    image: string
    options?: GoodsOptionsUncheckedCreateNestedManyWithoutGoodsInput
    confirmation?: GoodsConfirmationUncheckedCreateNestedOneWithoutGoodsInput
  }

  export type GoodsUpdateInput = {
    goods_name?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    goods_status?: EnumGoodsStatusFieldUpdateOperationsInput | GoodsStatus
    cancel_type?: StringFieldUpdateOperationsInput | string
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    contents_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    common_contents?: StringFieldUpdateOperationsInput | string
    shipping_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    goods_shipping_policy?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    unlimit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_ea?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_subprice?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_weight_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    min_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    min_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    max_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_urchase_order_limit?: NullableIntFieldUpdateOperationsInput | number | null
    admin_memo?: NullableStringFieldUpdateOperationsInput | string | null
    option_use?: StringFieldUpdateOperationsInput | string
    option_view_type?: EnumOptionViewTypeFieldUpdateOperationsInput | OptionViewType
    option_suboption_use?: StringFieldUpdateOperationsInput | string
    member_input_use?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    seller?: SellerUpdateOneRequiredWithoutGoodsInput
    options?: GoodsOptionsUpdateManyWithoutGoodsInput
    confirmation?: GoodsConfirmationUpdateOneWithoutGoodsInput
  }

  export type GoodsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    goods_name?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    goods_status?: EnumGoodsStatusFieldUpdateOperationsInput | GoodsStatus
    cancel_type?: StringFieldUpdateOperationsInput | string
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    contents_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    common_contents?: StringFieldUpdateOperationsInput | string
    shipping_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    goods_shipping_policy?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    unlimit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_ea?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_subprice?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_weight_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    min_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    min_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    max_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_urchase_order_limit?: NullableIntFieldUpdateOperationsInput | number | null
    admin_memo?: NullableStringFieldUpdateOperationsInput | string | null
    option_use?: StringFieldUpdateOperationsInput | string
    option_view_type?: EnumOptionViewTypeFieldUpdateOperationsInput | OptionViewType
    option_suboption_use?: StringFieldUpdateOperationsInput | string
    member_input_use?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    options?: GoodsOptionsUncheckedUpdateManyWithoutGoodsInput
    confirmation?: GoodsConfirmationUncheckedUpdateOneWithoutGoodsInput
  }

  export type GoodsCreateManyInput = {
    id?: number
    sellerId: number
    goods_name: string
    summary: string
    goods_status?: GoodsStatus
    cancel_type?: string
    contents?: string | null
    contents_mobile?: string | null
    common_contents: string
    shipping_policy?: ShopOrGoods
    goods_shipping_policy?: LimitOrUnlimit
    unlimit_shipping_price?: number | null
    limit_shipping_ea?: number | null
    limit_shipping_price?: number | null
    limit_shipping_subprice?: number | null
    shipping_weight_policy?: ShopOrGoods
    min_purchase_limit?: LimitOrUnlimit
    min_purchase_ea?: number | null
    max_purchase_limit?: LimitOrUnlimit
    max_purchase_ea?: number | null
    max_urchase_order_limit?: number | null
    admin_memo?: string | null
    option_use?: string
    option_view_type?: OptionViewType
    option_suboption_use?: string
    member_input_use?: string
    image: string
  }

  export type GoodsUpdateManyMutationInput = {
    goods_name?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    goods_status?: EnumGoodsStatusFieldUpdateOperationsInput | GoodsStatus
    cancel_type?: StringFieldUpdateOperationsInput | string
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    contents_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    common_contents?: StringFieldUpdateOperationsInput | string
    shipping_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    goods_shipping_policy?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    unlimit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_ea?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_subprice?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_weight_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    min_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    min_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    max_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_urchase_order_limit?: NullableIntFieldUpdateOperationsInput | number | null
    admin_memo?: NullableStringFieldUpdateOperationsInput | string | null
    option_use?: StringFieldUpdateOperationsInput | string
    option_view_type?: EnumOptionViewTypeFieldUpdateOperationsInput | OptionViewType
    option_suboption_use?: StringFieldUpdateOperationsInput | string
    member_input_use?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type GoodsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    goods_name?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    goods_status?: EnumGoodsStatusFieldUpdateOperationsInput | GoodsStatus
    cancel_type?: StringFieldUpdateOperationsInput | string
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    contents_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    common_contents?: StringFieldUpdateOperationsInput | string
    shipping_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    goods_shipping_policy?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    unlimit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_ea?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_subprice?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_weight_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    min_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    min_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    max_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_urchase_order_limit?: NullableIntFieldUpdateOperationsInput | number | null
    admin_memo?: NullableStringFieldUpdateOperationsInput | string | null
    option_use?: StringFieldUpdateOperationsInput | string
    option_view_type?: EnumOptionViewTypeFieldUpdateOperationsInput | OptionViewType
    option_suboption_use?: StringFieldUpdateOperationsInput | string
    member_input_use?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type GoodsConfirmationCreateInput = {
    id: number
    status?: GoodsConfirmationStatuses
    firstmallGoodsConnectionId?: number | null
    goods: GoodsCreateNestedOneWithoutConfirmationInput
  }

  export type GoodsConfirmationUncheckedCreateInput = {
    id: number
    goodsId: number
    status?: GoodsConfirmationStatuses
    firstmallGoodsConnectionId?: number | null
  }

  export type GoodsConfirmationUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumGoodsConfirmationStatusesFieldUpdateOperationsInput | GoodsConfirmationStatuses
    firstmallGoodsConnectionId?: NullableIntFieldUpdateOperationsInput | number | null
    goods?: GoodsUpdateOneRequiredWithoutConfirmationInput
  }

  export type GoodsConfirmationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    goodsId?: IntFieldUpdateOperationsInput | number
    status?: EnumGoodsConfirmationStatusesFieldUpdateOperationsInput | GoodsConfirmationStatuses
    firstmallGoodsConnectionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GoodsConfirmationCreateManyInput = {
    id: number
    goodsId: number
    status?: GoodsConfirmationStatuses
    firstmallGoodsConnectionId?: number | null
  }

  export type GoodsConfirmationUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumGoodsConfirmationStatusesFieldUpdateOperationsInput | GoodsConfirmationStatuses
    firstmallGoodsConnectionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GoodsConfirmationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    goodsId?: IntFieldUpdateOperationsInput | number
    status?: EnumGoodsConfirmationStatusesFieldUpdateOperationsInput | GoodsConfirmationStatuses
    firstmallGoodsConnectionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GoodsOptionsCreateInput = {
    default_option?: YesOrNo
    option_type?: string
    option_title?: string | null
    option_code?: string | null
    consumer_price: Decimal | number | string
    price: Decimal | number | string
    color?: string | null
    weight?: number | null
    option_view?: YesOrNo_UPPERCASE
    goods: GoodsCreateNestedOneWithoutOptionsInput
    supply?: GoodsOptionsSuppliesCreateNestedManyWithoutGoodsOptionsInput
  }

  export type GoodsOptionsUncheckedCreateInput = {
    id?: number
    goodsId: number
    default_option?: YesOrNo
    option_type?: string
    option_title?: string | null
    option_code?: string | null
    consumer_price: Decimal | number | string
    price: Decimal | number | string
    color?: string | null
    weight?: number | null
    option_view?: YesOrNo_UPPERCASE
    supply?: GoodsOptionsSuppliesUncheckedCreateNestedManyWithoutGoodsOptionsInput
  }

  export type GoodsOptionsUpdateInput = {
    default_option?: EnumYesOrNoFieldUpdateOperationsInput | YesOrNo
    option_type?: StringFieldUpdateOperationsInput | string
    option_title?: NullableStringFieldUpdateOperationsInput | string | null
    option_code?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    option_view?: EnumYesOrNo_UPPERCASEFieldUpdateOperationsInput | YesOrNo_UPPERCASE
    goods?: GoodsUpdateOneRequiredWithoutOptionsInput
    supply?: GoodsOptionsSuppliesUpdateManyWithoutGoodsOptionsInput
  }

  export type GoodsOptionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    goodsId?: IntFieldUpdateOperationsInput | number
    default_option?: EnumYesOrNoFieldUpdateOperationsInput | YesOrNo
    option_type?: StringFieldUpdateOperationsInput | string
    option_title?: NullableStringFieldUpdateOperationsInput | string | null
    option_code?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    option_view?: EnumYesOrNo_UPPERCASEFieldUpdateOperationsInput | YesOrNo_UPPERCASE
    supply?: GoodsOptionsSuppliesUncheckedUpdateManyWithoutGoodsOptionsInput
  }

  export type GoodsOptionsCreateManyInput = {
    id?: number
    goodsId: number
    default_option?: YesOrNo
    option_type?: string
    option_title?: string | null
    option_code?: string | null
    consumer_price: Decimal | number | string
    price: Decimal | number | string
    color?: string | null
    weight?: number | null
    option_view?: YesOrNo_UPPERCASE
  }

  export type GoodsOptionsUpdateManyMutationInput = {
    default_option?: EnumYesOrNoFieldUpdateOperationsInput | YesOrNo
    option_type?: StringFieldUpdateOperationsInput | string
    option_title?: NullableStringFieldUpdateOperationsInput | string | null
    option_code?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    option_view?: EnumYesOrNo_UPPERCASEFieldUpdateOperationsInput | YesOrNo_UPPERCASE
  }

  export type GoodsOptionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    goodsId?: IntFieldUpdateOperationsInput | number
    default_option?: EnumYesOrNoFieldUpdateOperationsInput | YesOrNo
    option_type?: StringFieldUpdateOperationsInput | string
    option_title?: NullableStringFieldUpdateOperationsInput | string | null
    option_code?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    option_view?: EnumYesOrNo_UPPERCASEFieldUpdateOperationsInput | YesOrNo_UPPERCASE
  }

  export type GoodsOptionsSuppliesCreateInput = {
    stock: number
    badstock?: number | null
    safe_stock?: number | null
    goodsOptions: GoodsOptionsCreateNestedOneWithoutSupplyInput
  }

  export type GoodsOptionsSuppliesUncheckedCreateInput = {
    id?: number
    goodsOptionsId: number
    stock: number
    badstock?: number | null
    safe_stock?: number | null
  }

  export type GoodsOptionsSuppliesUpdateInput = {
    stock?: IntFieldUpdateOperationsInput | number
    badstock?: NullableIntFieldUpdateOperationsInput | number | null
    safe_stock?: NullableIntFieldUpdateOperationsInput | number | null
    goodsOptions?: GoodsOptionsUpdateOneRequiredWithoutSupplyInput
  }

  export type GoodsOptionsSuppliesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    goodsOptionsId?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    badstock?: NullableIntFieldUpdateOperationsInput | number | null
    safe_stock?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GoodsOptionsSuppliesCreateManyInput = {
    id?: number
    goodsOptionsId: number
    stock: number
    badstock?: number | null
    safe_stock?: number | null
  }

  export type GoodsOptionsSuppliesUpdateManyMutationInput = {
    stock?: IntFieldUpdateOperationsInput | number
    badstock?: NullableIntFieldUpdateOperationsInput | number | null
    safe_stock?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GoodsOptionsSuppliesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    goodsOptionsId?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    badstock?: NullableIntFieldUpdateOperationsInput | number | null
    safe_stock?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LiveCommerceRankingCreateInput = {
    nickname?: string
    text: string
    price: number
    phoneCallEventFlag?: string
    loginFlag?: string
    createdAt?: Date | string
  }

  export type LiveCommerceRankingUncheckedCreateInput = {
    id?: number
    nickname?: string
    text: string
    price: number
    phoneCallEventFlag?: string
    loginFlag?: string
    createdAt?: Date | string
  }

  export type LiveCommerceRankingUpdateInput = {
    nickname?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    phoneCallEventFlag?: StringFieldUpdateOperationsInput | string
    loginFlag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveCommerceRankingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    phoneCallEventFlag?: StringFieldUpdateOperationsInput | string
    loginFlag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveCommerceRankingCreateManyInput = {
    id?: number
    nickname?: string
    text: string
    price: number
    phoneCallEventFlag?: string
    loginFlag?: string
    createdAt?: Date | string
  }

  export type LiveCommerceRankingUpdateManyMutationInput = {
    nickname?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    phoneCallEventFlag?: StringFieldUpdateOperationsInput | string
    loginFlag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveCommerceRankingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    phoneCallEventFlag?: StringFieldUpdateOperationsInput | string
    loginFlag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type SellerSocialAccountListRelationFilter = {
    every?: SellerSocialAccountWhereInput
    some?: SellerSocialAccountWhereInput
    none?: SellerSocialAccountWhereInput
  }

  export type GoodsListRelationFilter = {
    every?: GoodsWhereInput
    some?: GoodsWhereInput
    none?: GoodsWhereInput
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeFilter
  }

  export type SellerRelationFilter = {
    is?: SellerWhereInput
    isNot?: SellerWhereInput
  }

  export type GoodsOptionsListRelationFilter = {
    every?: GoodsOptionsWhereInput
    some?: GoodsOptionsWhereInput
    none?: GoodsOptionsWhereInput
  }

  export type GoodsConfirmationRelationFilter = {
    is?: GoodsConfirmationWhereInput | null
    isNot?: GoodsConfirmationWhereInput | null
  }

  export type EnumGoodsStatusFilter = {
    equals?: GoodsStatus
    in?: Enumerable<GoodsStatus>
    notIn?: Enumerable<GoodsStatus>
    not?: NestedEnumGoodsStatusFilter | GoodsStatus
  }

  export type EnumShopOrGoodsFilter = {
    equals?: ShopOrGoods
    in?: Enumerable<ShopOrGoods>
    notIn?: Enumerable<ShopOrGoods>
    not?: NestedEnumShopOrGoodsFilter | ShopOrGoods
  }

  export type EnumLimitOrUnlimitFilter = {
    equals?: LimitOrUnlimit
    in?: Enumerable<LimitOrUnlimit>
    notIn?: Enumerable<LimitOrUnlimit>
    not?: NestedEnumLimitOrUnlimitFilter | LimitOrUnlimit
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type EnumOptionViewTypeFilter = {
    equals?: OptionViewType
    in?: Enumerable<OptionViewType>
    notIn?: Enumerable<OptionViewType>
    not?: NestedEnumOptionViewTypeFilter | OptionViewType
  }

  export type EnumGoodsStatusWithAggregatesFilter = {
    equals?: GoodsStatus
    in?: Enumerable<GoodsStatus>
    notIn?: Enumerable<GoodsStatus>
    not?: NestedEnumGoodsStatusWithAggregatesFilter | GoodsStatus
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumGoodsStatusFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumGoodsStatusFilter
    _max?: NestedEnumGoodsStatusFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumGoodsStatusFilter
  }

  export type EnumShopOrGoodsWithAggregatesFilter = {
    equals?: ShopOrGoods
    in?: Enumerable<ShopOrGoods>
    notIn?: Enumerable<ShopOrGoods>
    not?: NestedEnumShopOrGoodsWithAggregatesFilter | ShopOrGoods
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumShopOrGoodsFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumShopOrGoodsFilter
    _max?: NestedEnumShopOrGoodsFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumShopOrGoodsFilter
  }

  export type EnumLimitOrUnlimitWithAggregatesFilter = {
    equals?: LimitOrUnlimit
    in?: Enumerable<LimitOrUnlimit>
    notIn?: Enumerable<LimitOrUnlimit>
    not?: NestedEnumLimitOrUnlimitWithAggregatesFilter | LimitOrUnlimit
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumLimitOrUnlimitFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumLimitOrUnlimitFilter
    _max?: NestedEnumLimitOrUnlimitFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumLimitOrUnlimitFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntNullableFilter
  }

  export type EnumOptionViewTypeWithAggregatesFilter = {
    equals?: OptionViewType
    in?: Enumerable<OptionViewType>
    notIn?: Enumerable<OptionViewType>
    not?: NestedEnumOptionViewTypeWithAggregatesFilter | OptionViewType
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumOptionViewTypeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumOptionViewTypeFilter
    _max?: NestedEnumOptionViewTypeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumOptionViewTypeFilter
  }

  export type GoodsRelationFilter = {
    is?: GoodsWhereInput
    isNot?: GoodsWhereInput
  }

  export type EnumGoodsConfirmationStatusesFilter = {
    equals?: GoodsConfirmationStatuses
    in?: Enumerable<GoodsConfirmationStatuses>
    notIn?: Enumerable<GoodsConfirmationStatuses>
    not?: NestedEnumGoodsConfirmationStatusesFilter | GoodsConfirmationStatuses
  }

  export type EnumGoodsConfirmationStatusesWithAggregatesFilter = {
    equals?: GoodsConfirmationStatuses
    in?: Enumerable<GoodsConfirmationStatuses>
    notIn?: Enumerable<GoodsConfirmationStatuses>
    not?: NestedEnumGoodsConfirmationStatusesWithAggregatesFilter | GoodsConfirmationStatuses
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumGoodsConfirmationStatusesFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumGoodsConfirmationStatusesFilter
    _max?: NestedEnumGoodsConfirmationStatusesFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumGoodsConfirmationStatusesFilter
  }

  export type GoodsOptionsSuppliesListRelationFilter = {
    every?: GoodsOptionsSuppliesWhereInput
    some?: GoodsOptionsSuppliesWhereInput
    none?: GoodsOptionsSuppliesWhereInput
  }

  export type EnumYesOrNoFilter = {
    equals?: YesOrNo
    in?: Enumerable<YesOrNo>
    notIn?: Enumerable<YesOrNo>
    not?: NestedEnumYesOrNoFilter | YesOrNo
  }

  export type DecimalFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalFilter | Decimal | number | string
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type EnumYesOrNo_UPPERCASEFilter = {
    equals?: YesOrNo_UPPERCASE
    in?: Enumerable<YesOrNo_UPPERCASE>
    notIn?: Enumerable<YesOrNo_UPPERCASE>
    not?: NestedEnumYesOrNo_UPPERCASEFilter | YesOrNo_UPPERCASE
  }

  export type EnumYesOrNoWithAggregatesFilter = {
    equals?: YesOrNo
    in?: Enumerable<YesOrNo>
    notIn?: Enumerable<YesOrNo>
    not?: NestedEnumYesOrNoWithAggregatesFilter | YesOrNo
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumYesOrNoFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumYesOrNoFilter
    _max?: NestedEnumYesOrNoFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumYesOrNoFilter
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | number | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDecimalFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedFloatNullableFilter
  }

  export type EnumYesOrNo_UPPERCASEWithAggregatesFilter = {
    equals?: YesOrNo_UPPERCASE
    in?: Enumerable<YesOrNo_UPPERCASE>
    notIn?: Enumerable<YesOrNo_UPPERCASE>
    not?: NestedEnumYesOrNo_UPPERCASEWithAggregatesFilter | YesOrNo_UPPERCASE
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumYesOrNo_UPPERCASEFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumYesOrNo_UPPERCASEFilter
    _max?: NestedEnumYesOrNo_UPPERCASEFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumYesOrNo_UPPERCASEFilter
  }

  export type GoodsOptionsRelationFilter = {
    is?: GoodsOptionsWhereInput
    isNot?: GoodsOptionsWhereInput
  }

  export type SellerSocialAccountCreateNestedManyWithoutSellerInput = {
    create?: XOR<Enumerable<SellerSocialAccountCreateWithoutSellerInput>, Enumerable<SellerSocialAccountUncheckedCreateWithoutSellerInput>>
    connectOrCreate?: Enumerable<SellerSocialAccountCreateOrConnectWithoutSellerInput>
    createMany?: SellerSocialAccountCreateManySellerInputEnvelope
    connect?: Enumerable<SellerSocialAccountWhereUniqueInput>
  }

  export type GoodsCreateNestedManyWithoutSellerInput = {
    create?: XOR<Enumerable<GoodsCreateWithoutSellerInput>, Enumerable<GoodsUncheckedCreateWithoutSellerInput>>
    connectOrCreate?: Enumerable<GoodsCreateOrConnectWithoutSellerInput>
    createMany?: GoodsCreateManySellerInputEnvelope
    connect?: Enumerable<GoodsWhereUniqueInput>
  }

  export type SellerSocialAccountUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<Enumerable<SellerSocialAccountCreateWithoutSellerInput>, Enumerable<SellerSocialAccountUncheckedCreateWithoutSellerInput>>
    connectOrCreate?: Enumerable<SellerSocialAccountCreateOrConnectWithoutSellerInput>
    createMany?: SellerSocialAccountCreateManySellerInputEnvelope
    connect?: Enumerable<SellerSocialAccountWhereUniqueInput>
  }

  export type GoodsUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<Enumerable<GoodsCreateWithoutSellerInput>, Enumerable<GoodsUncheckedCreateWithoutSellerInput>>
    connectOrCreate?: Enumerable<GoodsCreateOrConnectWithoutSellerInput>
    createMany?: GoodsCreateManySellerInputEnvelope
    connect?: Enumerable<GoodsWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type SellerSocialAccountUpdateManyWithoutSellerInput = {
    create?: XOR<Enumerable<SellerSocialAccountCreateWithoutSellerInput>, Enumerable<SellerSocialAccountUncheckedCreateWithoutSellerInput>>
    connectOrCreate?: Enumerable<SellerSocialAccountCreateOrConnectWithoutSellerInput>
    upsert?: Enumerable<SellerSocialAccountUpsertWithWhereUniqueWithoutSellerInput>
    createMany?: SellerSocialAccountCreateManySellerInputEnvelope
    connect?: Enumerable<SellerSocialAccountWhereUniqueInput>
    set?: Enumerable<SellerSocialAccountWhereUniqueInput>
    disconnect?: Enumerable<SellerSocialAccountWhereUniqueInput>
    delete?: Enumerable<SellerSocialAccountWhereUniqueInput>
    update?: Enumerable<SellerSocialAccountUpdateWithWhereUniqueWithoutSellerInput>
    updateMany?: Enumerable<SellerSocialAccountUpdateManyWithWhereWithoutSellerInput>
    deleteMany?: Enumerable<SellerSocialAccountScalarWhereInput>
  }

  export type GoodsUpdateManyWithoutSellerInput = {
    create?: XOR<Enumerable<GoodsCreateWithoutSellerInput>, Enumerable<GoodsUncheckedCreateWithoutSellerInput>>
    connectOrCreate?: Enumerable<GoodsCreateOrConnectWithoutSellerInput>
    upsert?: Enumerable<GoodsUpsertWithWhereUniqueWithoutSellerInput>
    createMany?: GoodsCreateManySellerInputEnvelope
    connect?: Enumerable<GoodsWhereUniqueInput>
    set?: Enumerable<GoodsWhereUniqueInput>
    disconnect?: Enumerable<GoodsWhereUniqueInput>
    delete?: Enumerable<GoodsWhereUniqueInput>
    update?: Enumerable<GoodsUpdateWithWhereUniqueWithoutSellerInput>
    updateMany?: Enumerable<GoodsUpdateManyWithWhereWithoutSellerInput>
    deleteMany?: Enumerable<GoodsScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SellerSocialAccountUncheckedUpdateManyWithoutSellerInput = {
    create?: XOR<Enumerable<SellerSocialAccountCreateWithoutSellerInput>, Enumerable<SellerSocialAccountUncheckedCreateWithoutSellerInput>>
    connectOrCreate?: Enumerable<SellerSocialAccountCreateOrConnectWithoutSellerInput>
    upsert?: Enumerable<SellerSocialAccountUpsertWithWhereUniqueWithoutSellerInput>
    createMany?: SellerSocialAccountCreateManySellerInputEnvelope
    connect?: Enumerable<SellerSocialAccountWhereUniqueInput>
    set?: Enumerable<SellerSocialAccountWhereUniqueInput>
    disconnect?: Enumerable<SellerSocialAccountWhereUniqueInput>
    delete?: Enumerable<SellerSocialAccountWhereUniqueInput>
    update?: Enumerable<SellerSocialAccountUpdateWithWhereUniqueWithoutSellerInput>
    updateMany?: Enumerable<SellerSocialAccountUpdateManyWithWhereWithoutSellerInput>
    deleteMany?: Enumerable<SellerSocialAccountScalarWhereInput>
  }

  export type GoodsUncheckedUpdateManyWithoutSellerInput = {
    create?: XOR<Enumerable<GoodsCreateWithoutSellerInput>, Enumerable<GoodsUncheckedCreateWithoutSellerInput>>
    connectOrCreate?: Enumerable<GoodsCreateOrConnectWithoutSellerInput>
    upsert?: Enumerable<GoodsUpsertWithWhereUniqueWithoutSellerInput>
    createMany?: GoodsCreateManySellerInputEnvelope
    connect?: Enumerable<GoodsWhereUniqueInput>
    set?: Enumerable<GoodsWhereUniqueInput>
    disconnect?: Enumerable<GoodsWhereUniqueInput>
    delete?: Enumerable<GoodsWhereUniqueInput>
    update?: Enumerable<GoodsUpdateWithWhereUniqueWithoutSellerInput>
    updateMany?: Enumerable<GoodsUpdateManyWithWhereWithoutSellerInput>
    deleteMany?: Enumerable<GoodsScalarWhereInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SellerCreateNestedOneWithoutSocialAccountsInput = {
    create?: XOR<SellerCreateWithoutSocialAccountsInput, SellerUncheckedCreateWithoutSocialAccountsInput>
    connectOrCreate?: SellerCreateOrConnectWithoutSocialAccountsInput
    connect?: SellerWhereUniqueInput
  }

  export type SellerUpdateOneRequiredWithoutSocialAccountsInput = {
    create?: XOR<SellerCreateWithoutSocialAccountsInput, SellerUncheckedCreateWithoutSocialAccountsInput>
    connectOrCreate?: SellerCreateOrConnectWithoutSocialAccountsInput
    upsert?: SellerUpsertWithoutSocialAccountsInput
    connect?: SellerWhereUniqueInput
    update?: XOR<SellerUpdateWithoutSocialAccountsInput, SellerUncheckedUpdateWithoutSocialAccountsInput>
  }

  export type SellerCreateNestedOneWithoutGoodsInput = {
    create?: XOR<SellerCreateWithoutGoodsInput, SellerUncheckedCreateWithoutGoodsInput>
    connectOrCreate?: SellerCreateOrConnectWithoutGoodsInput
    connect?: SellerWhereUniqueInput
  }

  export type GoodsOptionsCreateNestedManyWithoutGoodsInput = {
    create?: XOR<Enumerable<GoodsOptionsCreateWithoutGoodsInput>, Enumerable<GoodsOptionsUncheckedCreateWithoutGoodsInput>>
    connectOrCreate?: Enumerable<GoodsOptionsCreateOrConnectWithoutGoodsInput>
    createMany?: GoodsOptionsCreateManyGoodsInputEnvelope
    connect?: Enumerable<GoodsOptionsWhereUniqueInput>
  }

  export type GoodsConfirmationCreateNestedOneWithoutGoodsInput = {
    create?: XOR<GoodsConfirmationCreateWithoutGoodsInput, GoodsConfirmationUncheckedCreateWithoutGoodsInput>
    connectOrCreate?: GoodsConfirmationCreateOrConnectWithoutGoodsInput
    connect?: GoodsConfirmationWhereUniqueInput
  }

  export type GoodsOptionsUncheckedCreateNestedManyWithoutGoodsInput = {
    create?: XOR<Enumerable<GoodsOptionsCreateWithoutGoodsInput>, Enumerable<GoodsOptionsUncheckedCreateWithoutGoodsInput>>
    connectOrCreate?: Enumerable<GoodsOptionsCreateOrConnectWithoutGoodsInput>
    createMany?: GoodsOptionsCreateManyGoodsInputEnvelope
    connect?: Enumerable<GoodsOptionsWhereUniqueInput>
  }

  export type GoodsConfirmationUncheckedCreateNestedOneWithoutGoodsInput = {
    create?: XOR<GoodsConfirmationCreateWithoutGoodsInput, GoodsConfirmationUncheckedCreateWithoutGoodsInput>
    connectOrCreate?: GoodsConfirmationCreateOrConnectWithoutGoodsInput
    connect?: GoodsConfirmationWhereUniqueInput
  }

  export type EnumGoodsStatusFieldUpdateOperationsInput = {
    set?: GoodsStatus
  }

  export type EnumShopOrGoodsFieldUpdateOperationsInput = {
    set?: ShopOrGoods
  }

  export type EnumLimitOrUnlimitFieldUpdateOperationsInput = {
    set?: LimitOrUnlimit
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumOptionViewTypeFieldUpdateOperationsInput = {
    set?: OptionViewType
  }

  export type SellerUpdateOneRequiredWithoutGoodsInput = {
    create?: XOR<SellerCreateWithoutGoodsInput, SellerUncheckedCreateWithoutGoodsInput>
    connectOrCreate?: SellerCreateOrConnectWithoutGoodsInput
    upsert?: SellerUpsertWithoutGoodsInput
    connect?: SellerWhereUniqueInput
    update?: XOR<SellerUpdateWithoutGoodsInput, SellerUncheckedUpdateWithoutGoodsInput>
  }

  export type GoodsOptionsUpdateManyWithoutGoodsInput = {
    create?: XOR<Enumerable<GoodsOptionsCreateWithoutGoodsInput>, Enumerable<GoodsOptionsUncheckedCreateWithoutGoodsInput>>
    connectOrCreate?: Enumerable<GoodsOptionsCreateOrConnectWithoutGoodsInput>
    upsert?: Enumerable<GoodsOptionsUpsertWithWhereUniqueWithoutGoodsInput>
    createMany?: GoodsOptionsCreateManyGoodsInputEnvelope
    connect?: Enumerable<GoodsOptionsWhereUniqueInput>
    set?: Enumerable<GoodsOptionsWhereUniqueInput>
    disconnect?: Enumerable<GoodsOptionsWhereUniqueInput>
    delete?: Enumerable<GoodsOptionsWhereUniqueInput>
    update?: Enumerable<GoodsOptionsUpdateWithWhereUniqueWithoutGoodsInput>
    updateMany?: Enumerable<GoodsOptionsUpdateManyWithWhereWithoutGoodsInput>
    deleteMany?: Enumerable<GoodsOptionsScalarWhereInput>
  }

  export type GoodsConfirmationUpdateOneWithoutGoodsInput = {
    create?: XOR<GoodsConfirmationCreateWithoutGoodsInput, GoodsConfirmationUncheckedCreateWithoutGoodsInput>
    connectOrCreate?: GoodsConfirmationCreateOrConnectWithoutGoodsInput
    upsert?: GoodsConfirmationUpsertWithoutGoodsInput
    connect?: GoodsConfirmationWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<GoodsConfirmationUpdateWithoutGoodsInput, GoodsConfirmationUncheckedUpdateWithoutGoodsInput>
  }

  export type GoodsOptionsUncheckedUpdateManyWithoutGoodsInput = {
    create?: XOR<Enumerable<GoodsOptionsCreateWithoutGoodsInput>, Enumerable<GoodsOptionsUncheckedCreateWithoutGoodsInput>>
    connectOrCreate?: Enumerable<GoodsOptionsCreateOrConnectWithoutGoodsInput>
    upsert?: Enumerable<GoodsOptionsUpsertWithWhereUniqueWithoutGoodsInput>
    createMany?: GoodsOptionsCreateManyGoodsInputEnvelope
    connect?: Enumerable<GoodsOptionsWhereUniqueInput>
    set?: Enumerable<GoodsOptionsWhereUniqueInput>
    disconnect?: Enumerable<GoodsOptionsWhereUniqueInput>
    delete?: Enumerable<GoodsOptionsWhereUniqueInput>
    update?: Enumerable<GoodsOptionsUpdateWithWhereUniqueWithoutGoodsInput>
    updateMany?: Enumerable<GoodsOptionsUpdateManyWithWhereWithoutGoodsInput>
    deleteMany?: Enumerable<GoodsOptionsScalarWhereInput>
  }

  export type GoodsConfirmationUncheckedUpdateOneWithoutGoodsInput = {
    create?: XOR<GoodsConfirmationCreateWithoutGoodsInput, GoodsConfirmationUncheckedCreateWithoutGoodsInput>
    connectOrCreate?: GoodsConfirmationCreateOrConnectWithoutGoodsInput
    upsert?: GoodsConfirmationUpsertWithoutGoodsInput
    connect?: GoodsConfirmationWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<GoodsConfirmationUpdateWithoutGoodsInput, GoodsConfirmationUncheckedUpdateWithoutGoodsInput>
  }

  export type GoodsCreateNestedOneWithoutConfirmationInput = {
    create?: XOR<GoodsCreateWithoutConfirmationInput, GoodsUncheckedCreateWithoutConfirmationInput>
    connectOrCreate?: GoodsCreateOrConnectWithoutConfirmationInput
    connect?: GoodsWhereUniqueInput
  }

  export type EnumGoodsConfirmationStatusesFieldUpdateOperationsInput = {
    set?: GoodsConfirmationStatuses
  }

  export type GoodsUpdateOneRequiredWithoutConfirmationInput = {
    create?: XOR<GoodsCreateWithoutConfirmationInput, GoodsUncheckedCreateWithoutConfirmationInput>
    connectOrCreate?: GoodsCreateOrConnectWithoutConfirmationInput
    upsert?: GoodsUpsertWithoutConfirmationInput
    connect?: GoodsWhereUniqueInput
    update?: XOR<GoodsUpdateWithoutConfirmationInput, GoodsUncheckedUpdateWithoutConfirmationInput>
  }

  export type GoodsCreateNestedOneWithoutOptionsInput = {
    create?: XOR<GoodsCreateWithoutOptionsInput, GoodsUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: GoodsCreateOrConnectWithoutOptionsInput
    connect?: GoodsWhereUniqueInput
  }

  export type GoodsOptionsSuppliesCreateNestedManyWithoutGoodsOptionsInput = {
    create?: XOR<Enumerable<GoodsOptionsSuppliesCreateWithoutGoodsOptionsInput>, Enumerable<GoodsOptionsSuppliesUncheckedCreateWithoutGoodsOptionsInput>>
    connectOrCreate?: Enumerable<GoodsOptionsSuppliesCreateOrConnectWithoutGoodsOptionsInput>
    createMany?: GoodsOptionsSuppliesCreateManyGoodsOptionsInputEnvelope
    connect?: Enumerable<GoodsOptionsSuppliesWhereUniqueInput>
  }

  export type GoodsOptionsSuppliesUncheckedCreateNestedManyWithoutGoodsOptionsInput = {
    create?: XOR<Enumerable<GoodsOptionsSuppliesCreateWithoutGoodsOptionsInput>, Enumerable<GoodsOptionsSuppliesUncheckedCreateWithoutGoodsOptionsInput>>
    connectOrCreate?: Enumerable<GoodsOptionsSuppliesCreateOrConnectWithoutGoodsOptionsInput>
    createMany?: GoodsOptionsSuppliesCreateManyGoodsOptionsInputEnvelope
    connect?: Enumerable<GoodsOptionsSuppliesWhereUniqueInput>
  }

  export type EnumYesOrNoFieldUpdateOperationsInput = {
    set?: YesOrNo
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | number | string
    increment?: Decimal | number | string
    decrement?: Decimal | number | string
    multiply?: Decimal | number | string
    divide?: Decimal | number | string
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumYesOrNo_UPPERCASEFieldUpdateOperationsInput = {
    set?: YesOrNo_UPPERCASE
  }

  export type GoodsUpdateOneRequiredWithoutOptionsInput = {
    create?: XOR<GoodsCreateWithoutOptionsInput, GoodsUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: GoodsCreateOrConnectWithoutOptionsInput
    upsert?: GoodsUpsertWithoutOptionsInput
    connect?: GoodsWhereUniqueInput
    update?: XOR<GoodsUpdateWithoutOptionsInput, GoodsUncheckedUpdateWithoutOptionsInput>
  }

  export type GoodsOptionsSuppliesUpdateManyWithoutGoodsOptionsInput = {
    create?: XOR<Enumerable<GoodsOptionsSuppliesCreateWithoutGoodsOptionsInput>, Enumerable<GoodsOptionsSuppliesUncheckedCreateWithoutGoodsOptionsInput>>
    connectOrCreate?: Enumerable<GoodsOptionsSuppliesCreateOrConnectWithoutGoodsOptionsInput>
    upsert?: Enumerable<GoodsOptionsSuppliesUpsertWithWhereUniqueWithoutGoodsOptionsInput>
    createMany?: GoodsOptionsSuppliesCreateManyGoodsOptionsInputEnvelope
    connect?: Enumerable<GoodsOptionsSuppliesWhereUniqueInput>
    set?: Enumerable<GoodsOptionsSuppliesWhereUniqueInput>
    disconnect?: Enumerable<GoodsOptionsSuppliesWhereUniqueInput>
    delete?: Enumerable<GoodsOptionsSuppliesWhereUniqueInput>
    update?: Enumerable<GoodsOptionsSuppliesUpdateWithWhereUniqueWithoutGoodsOptionsInput>
    updateMany?: Enumerable<GoodsOptionsSuppliesUpdateManyWithWhereWithoutGoodsOptionsInput>
    deleteMany?: Enumerable<GoodsOptionsSuppliesScalarWhereInput>
  }

  export type GoodsOptionsSuppliesUncheckedUpdateManyWithoutGoodsOptionsInput = {
    create?: XOR<Enumerable<GoodsOptionsSuppliesCreateWithoutGoodsOptionsInput>, Enumerable<GoodsOptionsSuppliesUncheckedCreateWithoutGoodsOptionsInput>>
    connectOrCreate?: Enumerable<GoodsOptionsSuppliesCreateOrConnectWithoutGoodsOptionsInput>
    upsert?: Enumerable<GoodsOptionsSuppliesUpsertWithWhereUniqueWithoutGoodsOptionsInput>
    createMany?: GoodsOptionsSuppliesCreateManyGoodsOptionsInputEnvelope
    connect?: Enumerable<GoodsOptionsSuppliesWhereUniqueInput>
    set?: Enumerable<GoodsOptionsSuppliesWhereUniqueInput>
    disconnect?: Enumerable<GoodsOptionsSuppliesWhereUniqueInput>
    delete?: Enumerable<GoodsOptionsSuppliesWhereUniqueInput>
    update?: Enumerable<GoodsOptionsSuppliesUpdateWithWhereUniqueWithoutGoodsOptionsInput>
    updateMany?: Enumerable<GoodsOptionsSuppliesUpdateManyWithWhereWithoutGoodsOptionsInput>
    deleteMany?: Enumerable<GoodsOptionsSuppliesScalarWhereInput>
  }

  export type GoodsOptionsCreateNestedOneWithoutSupplyInput = {
    create?: XOR<GoodsOptionsCreateWithoutSupplyInput, GoodsOptionsUncheckedCreateWithoutSupplyInput>
    connectOrCreate?: GoodsOptionsCreateOrConnectWithoutSupplyInput
    connect?: GoodsOptionsWhereUniqueInput
  }

  export type GoodsOptionsUpdateOneRequiredWithoutSupplyInput = {
    create?: XOR<GoodsOptionsCreateWithoutSupplyInput, GoodsOptionsUncheckedCreateWithoutSupplyInput>
    connectOrCreate?: GoodsOptionsCreateOrConnectWithoutSupplyInput
    upsert?: GoodsOptionsUpsertWithoutSupplyInput
    connect?: GoodsOptionsWhereUniqueInput
    update?: XOR<GoodsOptionsUpdateWithoutSupplyInput, GoodsOptionsUncheckedUpdateWithoutSupplyInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeFilter
  }

  export type NestedEnumGoodsStatusFilter = {
    equals?: GoodsStatus
    in?: Enumerable<GoodsStatus>
    notIn?: Enumerable<GoodsStatus>
    not?: NestedEnumGoodsStatusFilter | GoodsStatus
  }

  export type NestedEnumShopOrGoodsFilter = {
    equals?: ShopOrGoods
    in?: Enumerable<ShopOrGoods>
    notIn?: Enumerable<ShopOrGoods>
    not?: NestedEnumShopOrGoodsFilter | ShopOrGoods
  }

  export type NestedEnumLimitOrUnlimitFilter = {
    equals?: LimitOrUnlimit
    in?: Enumerable<LimitOrUnlimit>
    notIn?: Enumerable<LimitOrUnlimit>
    not?: NestedEnumLimitOrUnlimitFilter | LimitOrUnlimit
  }

  export type NestedEnumOptionViewTypeFilter = {
    equals?: OptionViewType
    in?: Enumerable<OptionViewType>
    notIn?: Enumerable<OptionViewType>
    not?: NestedEnumOptionViewTypeFilter | OptionViewType
  }

  export type NestedEnumGoodsStatusWithAggregatesFilter = {
    equals?: GoodsStatus
    in?: Enumerable<GoodsStatus>
    notIn?: Enumerable<GoodsStatus>
    not?: NestedEnumGoodsStatusWithAggregatesFilter | GoodsStatus
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumGoodsStatusFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumGoodsStatusFilter
    _max?: NestedEnumGoodsStatusFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumGoodsStatusFilter
  }

  export type NestedEnumShopOrGoodsWithAggregatesFilter = {
    equals?: ShopOrGoods
    in?: Enumerable<ShopOrGoods>
    notIn?: Enumerable<ShopOrGoods>
    not?: NestedEnumShopOrGoodsWithAggregatesFilter | ShopOrGoods
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumShopOrGoodsFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumShopOrGoodsFilter
    _max?: NestedEnumShopOrGoodsFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumShopOrGoodsFilter
  }

  export type NestedEnumLimitOrUnlimitWithAggregatesFilter = {
    equals?: LimitOrUnlimit
    in?: Enumerable<LimitOrUnlimit>
    notIn?: Enumerable<LimitOrUnlimit>
    not?: NestedEnumLimitOrUnlimitWithAggregatesFilter | LimitOrUnlimit
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumLimitOrUnlimitFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumLimitOrUnlimitFilter
    _max?: NestedEnumLimitOrUnlimitFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumLimitOrUnlimitFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumOptionViewTypeWithAggregatesFilter = {
    equals?: OptionViewType
    in?: Enumerable<OptionViewType>
    notIn?: Enumerable<OptionViewType>
    not?: NestedEnumOptionViewTypeWithAggregatesFilter | OptionViewType
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumOptionViewTypeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumOptionViewTypeFilter
    _max?: NestedEnumOptionViewTypeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumOptionViewTypeFilter
  }

  export type NestedEnumGoodsConfirmationStatusesFilter = {
    equals?: GoodsConfirmationStatuses
    in?: Enumerable<GoodsConfirmationStatuses>
    notIn?: Enumerable<GoodsConfirmationStatuses>
    not?: NestedEnumGoodsConfirmationStatusesFilter | GoodsConfirmationStatuses
  }

  export type NestedEnumGoodsConfirmationStatusesWithAggregatesFilter = {
    equals?: GoodsConfirmationStatuses
    in?: Enumerable<GoodsConfirmationStatuses>
    notIn?: Enumerable<GoodsConfirmationStatuses>
    not?: NestedEnumGoodsConfirmationStatusesWithAggregatesFilter | GoodsConfirmationStatuses
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumGoodsConfirmationStatusesFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumGoodsConfirmationStatusesFilter
    _max?: NestedEnumGoodsConfirmationStatusesFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumGoodsConfirmationStatusesFilter
  }

  export type NestedEnumYesOrNoFilter = {
    equals?: YesOrNo
    in?: Enumerable<YesOrNo>
    notIn?: Enumerable<YesOrNo>
    not?: NestedEnumYesOrNoFilter | YesOrNo
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalFilter | Decimal | number | string
  }

  export type NestedEnumYesOrNo_UPPERCASEFilter = {
    equals?: YesOrNo_UPPERCASE
    in?: Enumerable<YesOrNo_UPPERCASE>
    notIn?: Enumerable<YesOrNo_UPPERCASE>
    not?: NestedEnumYesOrNo_UPPERCASEFilter | YesOrNo_UPPERCASE
  }

  export type NestedEnumYesOrNoWithAggregatesFilter = {
    equals?: YesOrNo
    in?: Enumerable<YesOrNo>
    notIn?: Enumerable<YesOrNo>
    not?: NestedEnumYesOrNoWithAggregatesFilter | YesOrNo
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumYesOrNoFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumYesOrNoFilter
    _max?: NestedEnumYesOrNoFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumYesOrNoFilter
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | number | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDecimalFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedFloatNullableFilter
  }

  export type NestedEnumYesOrNo_UPPERCASEWithAggregatesFilter = {
    equals?: YesOrNo_UPPERCASE
    in?: Enumerable<YesOrNo_UPPERCASE>
    notIn?: Enumerable<YesOrNo_UPPERCASE>
    not?: NestedEnumYesOrNo_UPPERCASEWithAggregatesFilter | YesOrNo_UPPERCASE
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumYesOrNo_UPPERCASEFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumYesOrNo_UPPERCASEFilter
    _max?: NestedEnumYesOrNo_UPPERCASEFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumYesOrNo_UPPERCASEFilter
  }

  export type SellerSocialAccountCreateWithoutSellerInput = {
    serviceId: string
    provider: string
    name: string
    registDate?: Date | string
    profileImage?: string | null
    accessToken?: string | null
    refreshToken?: string | null
  }

  export type SellerSocialAccountUncheckedCreateWithoutSellerInput = {
    serviceId: string
    provider: string
    name: string
    registDate?: Date | string
    profileImage?: string | null
    accessToken?: string | null
    refreshToken?: string | null
  }

  export type SellerSocialAccountCreateOrConnectWithoutSellerInput = {
    where: SellerSocialAccountWhereUniqueInput
    create: XOR<SellerSocialAccountCreateWithoutSellerInput, SellerSocialAccountUncheckedCreateWithoutSellerInput>
  }

  export type SellerSocialAccountCreateManySellerInputEnvelope = {
    data: Enumerable<SellerSocialAccountCreateManySellerInput>
    skipDuplicates?: boolean
  }

  export type GoodsCreateWithoutSellerInput = {
    goods_name: string
    summary: string
    goods_status?: GoodsStatus
    cancel_type?: string
    contents?: string | null
    contents_mobile?: string | null
    common_contents: string
    shipping_policy?: ShopOrGoods
    goods_shipping_policy?: LimitOrUnlimit
    unlimit_shipping_price?: number | null
    limit_shipping_ea?: number | null
    limit_shipping_price?: number | null
    limit_shipping_subprice?: number | null
    shipping_weight_policy?: ShopOrGoods
    min_purchase_limit?: LimitOrUnlimit
    min_purchase_ea?: number | null
    max_purchase_limit?: LimitOrUnlimit
    max_purchase_ea?: number | null
    max_urchase_order_limit?: number | null
    admin_memo?: string | null
    option_use?: string
    option_view_type?: OptionViewType
    option_suboption_use?: string
    member_input_use?: string
    image: string
    options?: GoodsOptionsCreateNestedManyWithoutGoodsInput
    confirmation?: GoodsConfirmationCreateNestedOneWithoutGoodsInput
  }

  export type GoodsUncheckedCreateWithoutSellerInput = {
    id?: number
    goods_name: string
    summary: string
    goods_status?: GoodsStatus
    cancel_type?: string
    contents?: string | null
    contents_mobile?: string | null
    common_contents: string
    shipping_policy?: ShopOrGoods
    goods_shipping_policy?: LimitOrUnlimit
    unlimit_shipping_price?: number | null
    limit_shipping_ea?: number | null
    limit_shipping_price?: number | null
    limit_shipping_subprice?: number | null
    shipping_weight_policy?: ShopOrGoods
    min_purchase_limit?: LimitOrUnlimit
    min_purchase_ea?: number | null
    max_purchase_limit?: LimitOrUnlimit
    max_purchase_ea?: number | null
    max_urchase_order_limit?: number | null
    admin_memo?: string | null
    option_use?: string
    option_view_type?: OptionViewType
    option_suboption_use?: string
    member_input_use?: string
    image: string
    options?: GoodsOptionsUncheckedCreateNestedManyWithoutGoodsInput
    confirmation?: GoodsConfirmationUncheckedCreateNestedOneWithoutGoodsInput
  }

  export type GoodsCreateOrConnectWithoutSellerInput = {
    where: GoodsWhereUniqueInput
    create: XOR<GoodsCreateWithoutSellerInput, GoodsUncheckedCreateWithoutSellerInput>
  }

  export type GoodsCreateManySellerInputEnvelope = {
    data: Enumerable<GoodsCreateManySellerInput>
    skipDuplicates?: boolean
  }

  export type SellerSocialAccountUpsertWithWhereUniqueWithoutSellerInput = {
    where: SellerSocialAccountWhereUniqueInput
    update: XOR<SellerSocialAccountUpdateWithoutSellerInput, SellerSocialAccountUncheckedUpdateWithoutSellerInput>
    create: XOR<SellerSocialAccountCreateWithoutSellerInput, SellerSocialAccountUncheckedCreateWithoutSellerInput>
  }

  export type SellerSocialAccountUpdateWithWhereUniqueWithoutSellerInput = {
    where: SellerSocialAccountWhereUniqueInput
    data: XOR<SellerSocialAccountUpdateWithoutSellerInput, SellerSocialAccountUncheckedUpdateWithoutSellerInput>
  }

  export type SellerSocialAccountUpdateManyWithWhereWithoutSellerInput = {
    where: SellerSocialAccountScalarWhereInput
    data: XOR<SellerSocialAccountUpdateManyMutationInput, SellerSocialAccountUncheckedUpdateManyWithoutSocialAccountsInput>
  }

  export type SellerSocialAccountScalarWhereInput = {
    AND?: Enumerable<SellerSocialAccountScalarWhereInput>
    OR?: Enumerable<SellerSocialAccountScalarWhereInput>
    NOT?: Enumerable<SellerSocialAccountScalarWhereInput>
    serviceId?: StringFilter | string
    provider?: StringFilter | string
    name?: StringFilter | string
    registDate?: DateTimeFilter | Date | string
    profileImage?: StringNullableFilter | string | null
    accessToken?: StringNullableFilter | string | null
    refreshToken?: StringNullableFilter | string | null
    sellerId?: IntFilter | number
  }

  export type GoodsUpsertWithWhereUniqueWithoutSellerInput = {
    where: GoodsWhereUniqueInput
    update: XOR<GoodsUpdateWithoutSellerInput, GoodsUncheckedUpdateWithoutSellerInput>
    create: XOR<GoodsCreateWithoutSellerInput, GoodsUncheckedCreateWithoutSellerInput>
  }

  export type GoodsUpdateWithWhereUniqueWithoutSellerInput = {
    where: GoodsWhereUniqueInput
    data: XOR<GoodsUpdateWithoutSellerInput, GoodsUncheckedUpdateWithoutSellerInput>
  }

  export type GoodsUpdateManyWithWhereWithoutSellerInput = {
    where: GoodsScalarWhereInput
    data: XOR<GoodsUpdateManyMutationInput, GoodsUncheckedUpdateManyWithoutGoodsInput>
  }

  export type GoodsScalarWhereInput = {
    AND?: Enumerable<GoodsScalarWhereInput>
    OR?: Enumerable<GoodsScalarWhereInput>
    NOT?: Enumerable<GoodsScalarWhereInput>
    id?: IntFilter | number
    sellerId?: IntFilter | number
    goods_name?: StringFilter | string
    summary?: StringFilter | string
    goods_status?: EnumGoodsStatusFilter | GoodsStatus
    cancel_type?: StringFilter | string
    contents?: StringNullableFilter | string | null
    contents_mobile?: StringNullableFilter | string | null
    common_contents?: StringFilter | string
    shipping_policy?: EnumShopOrGoodsFilter | ShopOrGoods
    goods_shipping_policy?: EnumLimitOrUnlimitFilter | LimitOrUnlimit
    unlimit_shipping_price?: IntNullableFilter | number | null
    limit_shipping_ea?: IntNullableFilter | number | null
    limit_shipping_price?: IntNullableFilter | number | null
    limit_shipping_subprice?: IntNullableFilter | number | null
    shipping_weight_policy?: EnumShopOrGoodsFilter | ShopOrGoods
    min_purchase_limit?: EnumLimitOrUnlimitFilter | LimitOrUnlimit
    min_purchase_ea?: IntNullableFilter | number | null
    max_purchase_limit?: EnumLimitOrUnlimitFilter | LimitOrUnlimit
    max_purchase_ea?: IntNullableFilter | number | null
    max_urchase_order_limit?: IntNullableFilter | number | null
    admin_memo?: StringNullableFilter | string | null
    option_use?: StringFilter | string
    option_view_type?: EnumOptionViewTypeFilter | OptionViewType
    option_suboption_use?: StringFilter | string
    member_input_use?: StringFilter | string
    image?: StringFilter | string
  }

  export type SellerCreateWithoutSocialAccountsInput = {
    email: string
    name?: string | null
    password?: string | null
    goods?: GoodsCreateNestedManyWithoutSellerInput
  }

  export type SellerUncheckedCreateWithoutSocialAccountsInput = {
    id?: number
    email: string
    name?: string | null
    password?: string | null
    goods?: GoodsUncheckedCreateNestedManyWithoutSellerInput
  }

  export type SellerCreateOrConnectWithoutSocialAccountsInput = {
    where: SellerWhereUniqueInput
    create: XOR<SellerCreateWithoutSocialAccountsInput, SellerUncheckedCreateWithoutSocialAccountsInput>
  }

  export type SellerUpsertWithoutSocialAccountsInput = {
    update: XOR<SellerUpdateWithoutSocialAccountsInput, SellerUncheckedUpdateWithoutSocialAccountsInput>
    create: XOR<SellerCreateWithoutSocialAccountsInput, SellerUncheckedCreateWithoutSocialAccountsInput>
  }

  export type SellerUpdateWithoutSocialAccountsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    goods?: GoodsUpdateManyWithoutSellerInput
  }

  export type SellerUncheckedUpdateWithoutSocialAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    goods?: GoodsUncheckedUpdateManyWithoutSellerInput
  }

  export type SellerCreateWithoutGoodsInput = {
    email: string
    name?: string | null
    password?: string | null
    socialAccounts?: SellerSocialAccountCreateNestedManyWithoutSellerInput
  }

  export type SellerUncheckedCreateWithoutGoodsInput = {
    id?: number
    email: string
    name?: string | null
    password?: string | null
    socialAccounts?: SellerSocialAccountUncheckedCreateNestedManyWithoutSellerInput
  }

  export type SellerCreateOrConnectWithoutGoodsInput = {
    where: SellerWhereUniqueInput
    create: XOR<SellerCreateWithoutGoodsInput, SellerUncheckedCreateWithoutGoodsInput>
  }

  export type GoodsOptionsCreateWithoutGoodsInput = {
    default_option?: YesOrNo
    option_type?: string
    option_title?: string | null
    option_code?: string | null
    consumer_price: Decimal | number | string
    price: Decimal | number | string
    color?: string | null
    weight?: number | null
    option_view?: YesOrNo_UPPERCASE
    supply?: GoodsOptionsSuppliesCreateNestedManyWithoutGoodsOptionsInput
  }

  export type GoodsOptionsUncheckedCreateWithoutGoodsInput = {
    id?: number
    default_option?: YesOrNo
    option_type?: string
    option_title?: string | null
    option_code?: string | null
    consumer_price: Decimal | number | string
    price: Decimal | number | string
    color?: string | null
    weight?: number | null
    option_view?: YesOrNo_UPPERCASE
    supply?: GoodsOptionsSuppliesUncheckedCreateNestedManyWithoutGoodsOptionsInput
  }

  export type GoodsOptionsCreateOrConnectWithoutGoodsInput = {
    where: GoodsOptionsWhereUniqueInput
    create: XOR<GoodsOptionsCreateWithoutGoodsInput, GoodsOptionsUncheckedCreateWithoutGoodsInput>
  }

  export type GoodsOptionsCreateManyGoodsInputEnvelope = {
    data: Enumerable<GoodsOptionsCreateManyGoodsInput>
    skipDuplicates?: boolean
  }

  export type GoodsConfirmationCreateWithoutGoodsInput = {
    id: number
    status?: GoodsConfirmationStatuses
    firstmallGoodsConnectionId?: number | null
  }

  export type GoodsConfirmationUncheckedCreateWithoutGoodsInput = {
    id: number
    status?: GoodsConfirmationStatuses
    firstmallGoodsConnectionId?: number | null
  }

  export type GoodsConfirmationCreateOrConnectWithoutGoodsInput = {
    where: GoodsConfirmationWhereUniqueInput
    create: XOR<GoodsConfirmationCreateWithoutGoodsInput, GoodsConfirmationUncheckedCreateWithoutGoodsInput>
  }

  export type SellerUpsertWithoutGoodsInput = {
    update: XOR<SellerUpdateWithoutGoodsInput, SellerUncheckedUpdateWithoutGoodsInput>
    create: XOR<SellerCreateWithoutGoodsInput, SellerUncheckedCreateWithoutGoodsInput>
  }

  export type SellerUpdateWithoutGoodsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    socialAccounts?: SellerSocialAccountUpdateManyWithoutSellerInput
  }

  export type SellerUncheckedUpdateWithoutGoodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    socialAccounts?: SellerSocialAccountUncheckedUpdateManyWithoutSellerInput
  }

  export type GoodsOptionsUpsertWithWhereUniqueWithoutGoodsInput = {
    where: GoodsOptionsWhereUniqueInput
    update: XOR<GoodsOptionsUpdateWithoutGoodsInput, GoodsOptionsUncheckedUpdateWithoutGoodsInput>
    create: XOR<GoodsOptionsCreateWithoutGoodsInput, GoodsOptionsUncheckedCreateWithoutGoodsInput>
  }

  export type GoodsOptionsUpdateWithWhereUniqueWithoutGoodsInput = {
    where: GoodsOptionsWhereUniqueInput
    data: XOR<GoodsOptionsUpdateWithoutGoodsInput, GoodsOptionsUncheckedUpdateWithoutGoodsInput>
  }

  export type GoodsOptionsUpdateManyWithWhereWithoutGoodsInput = {
    where: GoodsOptionsScalarWhereInput
    data: XOR<GoodsOptionsUpdateManyMutationInput, GoodsOptionsUncheckedUpdateManyWithoutOptionsInput>
  }

  export type GoodsOptionsScalarWhereInput = {
    AND?: Enumerable<GoodsOptionsScalarWhereInput>
    OR?: Enumerable<GoodsOptionsScalarWhereInput>
    NOT?: Enumerable<GoodsOptionsScalarWhereInput>
    id?: IntFilter | number
    goodsId?: IntFilter | number
    default_option?: EnumYesOrNoFilter | YesOrNo
    option_type?: StringFilter | string
    option_title?: StringNullableFilter | string | null
    option_code?: StringNullableFilter | string | null
    consumer_price?: DecimalFilter | Decimal | number | string
    price?: DecimalFilter | Decimal | number | string
    color?: StringNullableFilter | string | null
    weight?: FloatNullableFilter | number | null
    option_view?: EnumYesOrNo_UPPERCASEFilter | YesOrNo_UPPERCASE
  }

  export type GoodsConfirmationUpsertWithoutGoodsInput = {
    update: XOR<GoodsConfirmationUpdateWithoutGoodsInput, GoodsConfirmationUncheckedUpdateWithoutGoodsInput>
    create: XOR<GoodsConfirmationCreateWithoutGoodsInput, GoodsConfirmationUncheckedCreateWithoutGoodsInput>
  }

  export type GoodsConfirmationUpdateWithoutGoodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumGoodsConfirmationStatusesFieldUpdateOperationsInput | GoodsConfirmationStatuses
    firstmallGoodsConnectionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GoodsConfirmationUncheckedUpdateWithoutGoodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumGoodsConfirmationStatusesFieldUpdateOperationsInput | GoodsConfirmationStatuses
    firstmallGoodsConnectionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GoodsCreateWithoutConfirmationInput = {
    goods_name: string
    summary: string
    goods_status?: GoodsStatus
    cancel_type?: string
    contents?: string | null
    contents_mobile?: string | null
    common_contents: string
    shipping_policy?: ShopOrGoods
    goods_shipping_policy?: LimitOrUnlimit
    unlimit_shipping_price?: number | null
    limit_shipping_ea?: number | null
    limit_shipping_price?: number | null
    limit_shipping_subprice?: number | null
    shipping_weight_policy?: ShopOrGoods
    min_purchase_limit?: LimitOrUnlimit
    min_purchase_ea?: number | null
    max_purchase_limit?: LimitOrUnlimit
    max_purchase_ea?: number | null
    max_urchase_order_limit?: number | null
    admin_memo?: string | null
    option_use?: string
    option_view_type?: OptionViewType
    option_suboption_use?: string
    member_input_use?: string
    image: string
    seller: SellerCreateNestedOneWithoutGoodsInput
    options?: GoodsOptionsCreateNestedManyWithoutGoodsInput
  }

  export type GoodsUncheckedCreateWithoutConfirmationInput = {
    id?: number
    sellerId: number
    goods_name: string
    summary: string
    goods_status?: GoodsStatus
    cancel_type?: string
    contents?: string | null
    contents_mobile?: string | null
    common_contents: string
    shipping_policy?: ShopOrGoods
    goods_shipping_policy?: LimitOrUnlimit
    unlimit_shipping_price?: number | null
    limit_shipping_ea?: number | null
    limit_shipping_price?: number | null
    limit_shipping_subprice?: number | null
    shipping_weight_policy?: ShopOrGoods
    min_purchase_limit?: LimitOrUnlimit
    min_purchase_ea?: number | null
    max_purchase_limit?: LimitOrUnlimit
    max_purchase_ea?: number | null
    max_urchase_order_limit?: number | null
    admin_memo?: string | null
    option_use?: string
    option_view_type?: OptionViewType
    option_suboption_use?: string
    member_input_use?: string
    image: string
    options?: GoodsOptionsUncheckedCreateNestedManyWithoutGoodsInput
  }

  export type GoodsCreateOrConnectWithoutConfirmationInput = {
    where: GoodsWhereUniqueInput
    create: XOR<GoodsCreateWithoutConfirmationInput, GoodsUncheckedCreateWithoutConfirmationInput>
  }

  export type GoodsUpsertWithoutConfirmationInput = {
    update: XOR<GoodsUpdateWithoutConfirmationInput, GoodsUncheckedUpdateWithoutConfirmationInput>
    create: XOR<GoodsCreateWithoutConfirmationInput, GoodsUncheckedCreateWithoutConfirmationInput>
  }

  export type GoodsUpdateWithoutConfirmationInput = {
    goods_name?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    goods_status?: EnumGoodsStatusFieldUpdateOperationsInput | GoodsStatus
    cancel_type?: StringFieldUpdateOperationsInput | string
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    contents_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    common_contents?: StringFieldUpdateOperationsInput | string
    shipping_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    goods_shipping_policy?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    unlimit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_ea?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_subprice?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_weight_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    min_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    min_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    max_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_urchase_order_limit?: NullableIntFieldUpdateOperationsInput | number | null
    admin_memo?: NullableStringFieldUpdateOperationsInput | string | null
    option_use?: StringFieldUpdateOperationsInput | string
    option_view_type?: EnumOptionViewTypeFieldUpdateOperationsInput | OptionViewType
    option_suboption_use?: StringFieldUpdateOperationsInput | string
    member_input_use?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    seller?: SellerUpdateOneRequiredWithoutGoodsInput
    options?: GoodsOptionsUpdateManyWithoutGoodsInput
  }

  export type GoodsUncheckedUpdateWithoutConfirmationInput = {
    id?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    goods_name?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    goods_status?: EnumGoodsStatusFieldUpdateOperationsInput | GoodsStatus
    cancel_type?: StringFieldUpdateOperationsInput | string
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    contents_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    common_contents?: StringFieldUpdateOperationsInput | string
    shipping_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    goods_shipping_policy?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    unlimit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_ea?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_subprice?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_weight_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    min_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    min_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    max_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_urchase_order_limit?: NullableIntFieldUpdateOperationsInput | number | null
    admin_memo?: NullableStringFieldUpdateOperationsInput | string | null
    option_use?: StringFieldUpdateOperationsInput | string
    option_view_type?: EnumOptionViewTypeFieldUpdateOperationsInput | OptionViewType
    option_suboption_use?: StringFieldUpdateOperationsInput | string
    member_input_use?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    options?: GoodsOptionsUncheckedUpdateManyWithoutGoodsInput
  }

  export type GoodsCreateWithoutOptionsInput = {
    goods_name: string
    summary: string
    goods_status?: GoodsStatus
    cancel_type?: string
    contents?: string | null
    contents_mobile?: string | null
    common_contents: string
    shipping_policy?: ShopOrGoods
    goods_shipping_policy?: LimitOrUnlimit
    unlimit_shipping_price?: number | null
    limit_shipping_ea?: number | null
    limit_shipping_price?: number | null
    limit_shipping_subprice?: number | null
    shipping_weight_policy?: ShopOrGoods
    min_purchase_limit?: LimitOrUnlimit
    min_purchase_ea?: number | null
    max_purchase_limit?: LimitOrUnlimit
    max_purchase_ea?: number | null
    max_urchase_order_limit?: number | null
    admin_memo?: string | null
    option_use?: string
    option_view_type?: OptionViewType
    option_suboption_use?: string
    member_input_use?: string
    image: string
    seller: SellerCreateNestedOneWithoutGoodsInput
    confirmation?: GoodsConfirmationCreateNestedOneWithoutGoodsInput
  }

  export type GoodsUncheckedCreateWithoutOptionsInput = {
    id?: number
    sellerId: number
    goods_name: string
    summary: string
    goods_status?: GoodsStatus
    cancel_type?: string
    contents?: string | null
    contents_mobile?: string | null
    common_contents: string
    shipping_policy?: ShopOrGoods
    goods_shipping_policy?: LimitOrUnlimit
    unlimit_shipping_price?: number | null
    limit_shipping_ea?: number | null
    limit_shipping_price?: number | null
    limit_shipping_subprice?: number | null
    shipping_weight_policy?: ShopOrGoods
    min_purchase_limit?: LimitOrUnlimit
    min_purchase_ea?: number | null
    max_purchase_limit?: LimitOrUnlimit
    max_purchase_ea?: number | null
    max_urchase_order_limit?: number | null
    admin_memo?: string | null
    option_use?: string
    option_view_type?: OptionViewType
    option_suboption_use?: string
    member_input_use?: string
    image: string
    confirmation?: GoodsConfirmationUncheckedCreateNestedOneWithoutGoodsInput
  }

  export type GoodsCreateOrConnectWithoutOptionsInput = {
    where: GoodsWhereUniqueInput
    create: XOR<GoodsCreateWithoutOptionsInput, GoodsUncheckedCreateWithoutOptionsInput>
  }

  export type GoodsOptionsSuppliesCreateWithoutGoodsOptionsInput = {
    stock: number
    badstock?: number | null
    safe_stock?: number | null
  }

  export type GoodsOptionsSuppliesUncheckedCreateWithoutGoodsOptionsInput = {
    id?: number
    stock: number
    badstock?: number | null
    safe_stock?: number | null
  }

  export type GoodsOptionsSuppliesCreateOrConnectWithoutGoodsOptionsInput = {
    where: GoodsOptionsSuppliesWhereUniqueInput
    create: XOR<GoodsOptionsSuppliesCreateWithoutGoodsOptionsInput, GoodsOptionsSuppliesUncheckedCreateWithoutGoodsOptionsInput>
  }

  export type GoodsOptionsSuppliesCreateManyGoodsOptionsInputEnvelope = {
    data: Enumerable<GoodsOptionsSuppliesCreateManyGoodsOptionsInput>
    skipDuplicates?: boolean
  }

  export type GoodsUpsertWithoutOptionsInput = {
    update: XOR<GoodsUpdateWithoutOptionsInput, GoodsUncheckedUpdateWithoutOptionsInput>
    create: XOR<GoodsCreateWithoutOptionsInput, GoodsUncheckedCreateWithoutOptionsInput>
  }

  export type GoodsUpdateWithoutOptionsInput = {
    goods_name?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    goods_status?: EnumGoodsStatusFieldUpdateOperationsInput | GoodsStatus
    cancel_type?: StringFieldUpdateOperationsInput | string
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    contents_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    common_contents?: StringFieldUpdateOperationsInput | string
    shipping_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    goods_shipping_policy?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    unlimit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_ea?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_subprice?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_weight_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    min_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    min_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    max_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_urchase_order_limit?: NullableIntFieldUpdateOperationsInput | number | null
    admin_memo?: NullableStringFieldUpdateOperationsInput | string | null
    option_use?: StringFieldUpdateOperationsInput | string
    option_view_type?: EnumOptionViewTypeFieldUpdateOperationsInput | OptionViewType
    option_suboption_use?: StringFieldUpdateOperationsInput | string
    member_input_use?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    seller?: SellerUpdateOneRequiredWithoutGoodsInput
    confirmation?: GoodsConfirmationUpdateOneWithoutGoodsInput
  }

  export type GoodsUncheckedUpdateWithoutOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sellerId?: IntFieldUpdateOperationsInput | number
    goods_name?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    goods_status?: EnumGoodsStatusFieldUpdateOperationsInput | GoodsStatus
    cancel_type?: StringFieldUpdateOperationsInput | string
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    contents_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    common_contents?: StringFieldUpdateOperationsInput | string
    shipping_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    goods_shipping_policy?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    unlimit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_ea?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_subprice?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_weight_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    min_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    min_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    max_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_urchase_order_limit?: NullableIntFieldUpdateOperationsInput | number | null
    admin_memo?: NullableStringFieldUpdateOperationsInput | string | null
    option_use?: StringFieldUpdateOperationsInput | string
    option_view_type?: EnumOptionViewTypeFieldUpdateOperationsInput | OptionViewType
    option_suboption_use?: StringFieldUpdateOperationsInput | string
    member_input_use?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    confirmation?: GoodsConfirmationUncheckedUpdateOneWithoutGoodsInput
  }

  export type GoodsOptionsSuppliesUpsertWithWhereUniqueWithoutGoodsOptionsInput = {
    where: GoodsOptionsSuppliesWhereUniqueInput
    update: XOR<GoodsOptionsSuppliesUpdateWithoutGoodsOptionsInput, GoodsOptionsSuppliesUncheckedUpdateWithoutGoodsOptionsInput>
    create: XOR<GoodsOptionsSuppliesCreateWithoutGoodsOptionsInput, GoodsOptionsSuppliesUncheckedCreateWithoutGoodsOptionsInput>
  }

  export type GoodsOptionsSuppliesUpdateWithWhereUniqueWithoutGoodsOptionsInput = {
    where: GoodsOptionsSuppliesWhereUniqueInput
    data: XOR<GoodsOptionsSuppliesUpdateWithoutGoodsOptionsInput, GoodsOptionsSuppliesUncheckedUpdateWithoutGoodsOptionsInput>
  }

  export type GoodsOptionsSuppliesUpdateManyWithWhereWithoutGoodsOptionsInput = {
    where: GoodsOptionsSuppliesScalarWhereInput
    data: XOR<GoodsOptionsSuppliesUpdateManyMutationInput, GoodsOptionsSuppliesUncheckedUpdateManyWithoutSupplyInput>
  }

  export type GoodsOptionsSuppliesScalarWhereInput = {
    AND?: Enumerable<GoodsOptionsSuppliesScalarWhereInput>
    OR?: Enumerable<GoodsOptionsSuppliesScalarWhereInput>
    NOT?: Enumerable<GoodsOptionsSuppliesScalarWhereInput>
    id?: IntFilter | number
    goodsOptionsId?: IntFilter | number
    stock?: IntFilter | number
    badstock?: IntNullableFilter | number | null
    safe_stock?: IntNullableFilter | number | null
  }

  export type GoodsOptionsCreateWithoutSupplyInput = {
    default_option?: YesOrNo
    option_type?: string
    option_title?: string | null
    option_code?: string | null
    consumer_price: Decimal | number | string
    price: Decimal | number | string
    color?: string | null
    weight?: number | null
    option_view?: YesOrNo_UPPERCASE
    goods: GoodsCreateNestedOneWithoutOptionsInput
  }

  export type GoodsOptionsUncheckedCreateWithoutSupplyInput = {
    id?: number
    goodsId: number
    default_option?: YesOrNo
    option_type?: string
    option_title?: string | null
    option_code?: string | null
    consumer_price: Decimal | number | string
    price: Decimal | number | string
    color?: string | null
    weight?: number | null
    option_view?: YesOrNo_UPPERCASE
  }

  export type GoodsOptionsCreateOrConnectWithoutSupplyInput = {
    where: GoodsOptionsWhereUniqueInput
    create: XOR<GoodsOptionsCreateWithoutSupplyInput, GoodsOptionsUncheckedCreateWithoutSupplyInput>
  }

  export type GoodsOptionsUpsertWithoutSupplyInput = {
    update: XOR<GoodsOptionsUpdateWithoutSupplyInput, GoodsOptionsUncheckedUpdateWithoutSupplyInput>
    create: XOR<GoodsOptionsCreateWithoutSupplyInput, GoodsOptionsUncheckedCreateWithoutSupplyInput>
  }

  export type GoodsOptionsUpdateWithoutSupplyInput = {
    default_option?: EnumYesOrNoFieldUpdateOperationsInput | YesOrNo
    option_type?: StringFieldUpdateOperationsInput | string
    option_title?: NullableStringFieldUpdateOperationsInput | string | null
    option_code?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    option_view?: EnumYesOrNo_UPPERCASEFieldUpdateOperationsInput | YesOrNo_UPPERCASE
    goods?: GoodsUpdateOneRequiredWithoutOptionsInput
  }

  export type GoodsOptionsUncheckedUpdateWithoutSupplyInput = {
    id?: IntFieldUpdateOperationsInput | number
    goodsId?: IntFieldUpdateOperationsInput | number
    default_option?: EnumYesOrNoFieldUpdateOperationsInput | YesOrNo
    option_type?: StringFieldUpdateOperationsInput | string
    option_title?: NullableStringFieldUpdateOperationsInput | string | null
    option_code?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    option_view?: EnumYesOrNo_UPPERCASEFieldUpdateOperationsInput | YesOrNo_UPPERCASE
  }

  export type SellerSocialAccountCreateManySellerInput = {
    serviceId: string
    provider: string
    name: string
    registDate?: Date | string
    profileImage?: string | null
    accessToken?: string | null
    refreshToken?: string | null
  }

  export type GoodsCreateManySellerInput = {
    id?: number
    goods_name: string
    summary: string
    goods_status?: GoodsStatus
    cancel_type?: string
    contents?: string | null
    contents_mobile?: string | null
    common_contents: string
    shipping_policy?: ShopOrGoods
    goods_shipping_policy?: LimitOrUnlimit
    unlimit_shipping_price?: number | null
    limit_shipping_ea?: number | null
    limit_shipping_price?: number | null
    limit_shipping_subprice?: number | null
    shipping_weight_policy?: ShopOrGoods
    min_purchase_limit?: LimitOrUnlimit
    min_purchase_ea?: number | null
    max_purchase_limit?: LimitOrUnlimit
    max_purchase_ea?: number | null
    max_urchase_order_limit?: number | null
    admin_memo?: string | null
    option_use?: string
    option_view_type?: OptionViewType
    option_suboption_use?: string
    member_input_use?: string
    image: string
  }

  export type SellerSocialAccountUpdateWithoutSellerInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    registDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SellerSocialAccountUncheckedUpdateWithoutSellerInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    registDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SellerSocialAccountUncheckedUpdateManyWithoutSocialAccountsInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    registDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GoodsUpdateWithoutSellerInput = {
    goods_name?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    goods_status?: EnumGoodsStatusFieldUpdateOperationsInput | GoodsStatus
    cancel_type?: StringFieldUpdateOperationsInput | string
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    contents_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    common_contents?: StringFieldUpdateOperationsInput | string
    shipping_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    goods_shipping_policy?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    unlimit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_ea?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_subprice?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_weight_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    min_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    min_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    max_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_urchase_order_limit?: NullableIntFieldUpdateOperationsInput | number | null
    admin_memo?: NullableStringFieldUpdateOperationsInput | string | null
    option_use?: StringFieldUpdateOperationsInput | string
    option_view_type?: EnumOptionViewTypeFieldUpdateOperationsInput | OptionViewType
    option_suboption_use?: StringFieldUpdateOperationsInput | string
    member_input_use?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    options?: GoodsOptionsUpdateManyWithoutGoodsInput
    confirmation?: GoodsConfirmationUpdateOneWithoutGoodsInput
  }

  export type GoodsUncheckedUpdateWithoutSellerInput = {
    id?: IntFieldUpdateOperationsInput | number
    goods_name?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    goods_status?: EnumGoodsStatusFieldUpdateOperationsInput | GoodsStatus
    cancel_type?: StringFieldUpdateOperationsInput | string
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    contents_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    common_contents?: StringFieldUpdateOperationsInput | string
    shipping_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    goods_shipping_policy?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    unlimit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_ea?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_subprice?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_weight_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    min_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    min_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    max_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_urchase_order_limit?: NullableIntFieldUpdateOperationsInput | number | null
    admin_memo?: NullableStringFieldUpdateOperationsInput | string | null
    option_use?: StringFieldUpdateOperationsInput | string
    option_view_type?: EnumOptionViewTypeFieldUpdateOperationsInput | OptionViewType
    option_suboption_use?: StringFieldUpdateOperationsInput | string
    member_input_use?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    options?: GoodsOptionsUncheckedUpdateManyWithoutGoodsInput
    confirmation?: GoodsConfirmationUncheckedUpdateOneWithoutGoodsInput
  }

  export type GoodsUncheckedUpdateManyWithoutGoodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    goods_name?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    goods_status?: EnumGoodsStatusFieldUpdateOperationsInput | GoodsStatus
    cancel_type?: StringFieldUpdateOperationsInput | string
    contents?: NullableStringFieldUpdateOperationsInput | string | null
    contents_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    common_contents?: StringFieldUpdateOperationsInput | string
    shipping_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    goods_shipping_policy?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    unlimit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_ea?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    limit_shipping_subprice?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_weight_policy?: EnumShopOrGoodsFieldUpdateOperationsInput | ShopOrGoods
    min_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    min_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_purchase_limit?: EnumLimitOrUnlimitFieldUpdateOperationsInput | LimitOrUnlimit
    max_purchase_ea?: NullableIntFieldUpdateOperationsInput | number | null
    max_urchase_order_limit?: NullableIntFieldUpdateOperationsInput | number | null
    admin_memo?: NullableStringFieldUpdateOperationsInput | string | null
    option_use?: StringFieldUpdateOperationsInput | string
    option_view_type?: EnumOptionViewTypeFieldUpdateOperationsInput | OptionViewType
    option_suboption_use?: StringFieldUpdateOperationsInput | string
    member_input_use?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type GoodsOptionsCreateManyGoodsInput = {
    id?: number
    default_option?: YesOrNo
    option_type?: string
    option_title?: string | null
    option_code?: string | null
    consumer_price: Decimal | number | string
    price: Decimal | number | string
    color?: string | null
    weight?: number | null
    option_view?: YesOrNo_UPPERCASE
  }

  export type GoodsOptionsUpdateWithoutGoodsInput = {
    default_option?: EnumYesOrNoFieldUpdateOperationsInput | YesOrNo
    option_type?: StringFieldUpdateOperationsInput | string
    option_title?: NullableStringFieldUpdateOperationsInput | string | null
    option_code?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    option_view?: EnumYesOrNo_UPPERCASEFieldUpdateOperationsInput | YesOrNo_UPPERCASE
    supply?: GoodsOptionsSuppliesUpdateManyWithoutGoodsOptionsInput
  }

  export type GoodsOptionsUncheckedUpdateWithoutGoodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_option?: EnumYesOrNoFieldUpdateOperationsInput | YesOrNo
    option_type?: StringFieldUpdateOperationsInput | string
    option_title?: NullableStringFieldUpdateOperationsInput | string | null
    option_code?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    option_view?: EnumYesOrNo_UPPERCASEFieldUpdateOperationsInput | YesOrNo_UPPERCASE
    supply?: GoodsOptionsSuppliesUncheckedUpdateManyWithoutGoodsOptionsInput
  }

  export type GoodsOptionsUncheckedUpdateManyWithoutOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_option?: EnumYesOrNoFieldUpdateOperationsInput | YesOrNo
    option_type?: StringFieldUpdateOperationsInput | string
    option_title?: NullableStringFieldUpdateOperationsInput | string | null
    option_code?: NullableStringFieldUpdateOperationsInput | string | null
    consumer_price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    option_view?: EnumYesOrNo_UPPERCASEFieldUpdateOperationsInput | YesOrNo_UPPERCASE
  }

  export type GoodsOptionsSuppliesCreateManyGoodsOptionsInput = {
    id?: number
    stock: number
    badstock?: number | null
    safe_stock?: number | null
  }

  export type GoodsOptionsSuppliesUpdateWithoutGoodsOptionsInput = {
    stock?: IntFieldUpdateOperationsInput | number
    badstock?: NullableIntFieldUpdateOperationsInput | number | null
    safe_stock?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GoodsOptionsSuppliesUncheckedUpdateWithoutGoodsOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    badstock?: NullableIntFieldUpdateOperationsInput | number | null
    safe_stock?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GoodsOptionsSuppliesUncheckedUpdateManyWithoutSupplyInput = {
    id?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    badstock?: NullableIntFieldUpdateOperationsInput | number | null
    safe_stock?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}